# Standard configuration stuff.

# Some bindings for the old UI (pretty much unused).

# bind '-' to 'bak'
app bind 45 [callback { bak }]

# bind '=' (under '+') to fwd
app bind 61 [callback { fwd }]

# Keeps track of the next track to be allocated with the "track" command.
var trackNum 0

# The current project.
var project 0

def makeProject {} {
    var result [[evtrec] Project $scriptDir]

    # bind 'm' ("mark") to write the position.
    app bind 109 [callback {
        var pos [tell]
        print 'marking ' $pos '\n'
        $project writeLog [format 'mark ' $pos '\n']
    }]

    $result bindControllerScript 41 {
        print 'got control event\n'
        if {event value} {
            print 'playing'
            play
        }
        print 'done with control event\n'
    }

    # Store in the project variable.
    set project $result

    give $result
}

# Default "track controller functions" -- see info below.
var tcf [object {
    def getVolCC {trackNum} {
        + [* $trackNum 256] 7
    }

    def getPanCC {trackNum} {
        + [* $trackNum 256] 10
    }
}]

def setTCF {newTCF} \
  'Set the track controller functions, an object with getVolCC(trackNum) and
   getPanCC(trackNum) methods that return the numeric controller ids for a
   given track number.

   Controller numbers correspond to midi_channel * 256 + midi_CC_code +
   controller_offset, where controller_offset is a parameter of the midi
   engine that can be set using ControllerOffsetChangeProcessor.  The offset
   allows controller bank switching (in which the controller number is
   itself modulated by a prior CC message) which seems to be a feature of some
   controllers.  See makeControllerOffsetChange for details.

   The default TCF set assumes that the track maps to the midi channel and
   that the volume and pan controllers are just the normal controllers for
   those parameters (7, and 10, respectively).

   setTCF <tcf-object>' {
    set tcf $newTCF
}

# Adds a new track.
def track {file} 'Add a new track file: track <filename>' {
    $project addTrack $file [tcf getVolCC $trackNum] [tcf getPanCC $trackNum]
    set trackNum [+ $trackNum 1]
}

def midiTrack {file} 'Add a new midi track: midiTrack <file>' {
    prerr [format 'loading midi file ' $file '\n']
    [getAWBEngine] loadMidiFile $file
}

# Adds a new "bus" (pass-through).
def bus {inputs} {
    $project addPassThrough $inputs [tcf getVolCC $trackNum] \
        [tcf getPanCC $trackNum]
    set trackNum [+ $trackNum 1]
}


def pan {track val} {
    $project setPan $track $val
}

def getPan {track} {
    $project getPan $track
}

def vol {track val} {
    $project setVol $track $val
}

def getVol {track} {
    $project getVol $track
}

def gain {track val} {
    $project setGain $track $val
}

def getGain {track} {
    $project getGain $track
}

var MidiRecorder [object {
    var eng [get_engine]

    def activate {} {
        eng addRecorder [makeMidiTrackRecorder]
    }

    def deactivate {} {
        eng clearRecorders
    }
}]

var AudioRecorder [object {
    var filename 'recording.wav'
    var enabled [+ 0]
    var eng [get_engine]

    def addRecorder {} {
        eng addRecorder [makeAudioFileRecorder $filename]
    }

    def activate {} {
        set enabled [+ 1]
        addRecorder
    }

    def deactivate {} {
        set enabled [+ 0]
        eng clearRecorders
    }

    def setFilename {newFilename} {
        set filename $newFilename
        if {give $enabled} {
            # Replace the existing recorder.
            eng clearRecorders
            addRecorder
        }
    }

    def getFilename {} {
        give $filename
    }
}]

def ToggleButton {parent size text model} \
    'Stateful text button that allows you to toggle the state of a model
    object.

    "model" must support "activate" and "deactivate" methods.

    usage: MidiState <parent> <size> <text> <recorder>
    ' \
{
    object {
        var active [+ 0]
        var win [StatefulText $parent $size $text]
        win bind $KEY_ENTER {
            if {give $active} {
                win setNormalAttr 66
                win setUnfocusedAttr 2
                set active [+ 0]
                model deactivate
            } else {
                self setNormalAttr 65
                self setUnfocusedAttr 1
                set active [+ 1]
                model activate
            }

            give 'true'
        }

        win setNormalAttr 66
        win setUnfocusedAttr 2
    }
}

def ActionButton {parent size text action} \
    'Stateful text button that performs an action.

    "action" is a command object that takes no arguments.

    usage: ActionButton <parent> <size> <text> <action>
    ' \
{
    var self [
        object {
            var win [StatefulText $parent $size $text]
            win bind $KEY_ENTER {
                action
            }

            def setText {text} {
                win setText $text
            }

            def getWindow {} {
                give $win
            }

            win setNormalAttr 71
            win setUnfocusedAttr 2
        }
    ]
}

## Display an entry bar in the given "parent" window.
##
## Call "enterCallback" with the entry text and restore the original parcel
## when the user presses "enter".
##
## "restoreFocus" is a widget to restore focus to.
def EntryBar {parent size label enterCallback restoreFocus} {
    object {
        var row [Row $parent $size]
        var label [StatefulText $row 10 $label]
        var entry [Entry $row -1]
        var lastParcel [parent getParcel]
        parent setParcel $row
        entry setFocus [+ 1]
        entry bind $KEY_ENTER {
            enterCallback [entry getText]
            parent setParcel $lastParcel
            restoreFocus setFocus [+ 1]
        }
    }
}

## Start a new menu.
##
## 'parent' is the container in which to place the menu (should be a Frame)
## and 'alternate' is the Window that we restore the focus to after the menu
## goes away (should provide the "setFocus" method).
def makeMenu {parent alternate} {
    var menu [List $parent -1]
    parent setParcel $menu
    menu setFocus 1
    var result [object {
        var actions [array]
        def add {text block} {
            menu add $text
            actions append $block
        }

        def selected {} {
            var action [actions get [menu getSelection]]

            # Clean up the menu, restore focus to the originator.
            parent setParcel $alternate
            alternate setFocus 1

            # Do the menu item action.
            $action
            give true
        }
    }]
    menu bind $KEY_ENTER { result selected }

    give $result
}

def AudioSource {name left right} {
    var self [object {
        # Alias the connect/disconnect functions so we can override and
        # delegate.
        var con $connect
        var dis $disconnect

        def connect {} 'connect the source to AWB input' {
            prerr [format 'calling connect ' $left ' and ' $right '\n']
            con $left 'awb:left_in'
            con $right 'awb:right_in'
        }

        def disconnect {} 'disconnect the source from AWB input' {
            dis $left 'awb:left_in'
            dis $right 'awb:right_in'
        }

        def getName {} { give $name }
        def makeAction {textWidget} {
            def action {} {
                RecordSourceManager connect $self
                textWidget setText $name
            }
        }
    }]
}

var NullAudioSource [
    var self [object {
        def connect {} {}
        def disconnect {} {}
        def getName {} { give 'null' }
        def makeAction {textWidget} {
            def action {} {
                RecordSourceManager connect $self
                textWidget setText 'null'
            }
        }
    }]
]

var RecordSourceManager [
    object {
        # Currently connected audio source.
        var cur $NullAudioSource

        ## Connect an audio source to the AWB recording inputs.
        ##
        ## source: AudioSource instance.
        def connect {source} {
            if {give $cur} {
                cur disconnect
            }
            source connect
            set cur $source
        }

        ## Returns the name of the current audio source.
        def getCurrentName {} { cur getName }
    }
]

# Audio sources.  Add your local sources to this array in your .awb.crash file.
# Example:
#   import [load_module awbconfig.crash] sources AudioSource
#   sources add [AudioSource 'zyn' 'zynaddsubfx:out_1' 'system:capture_2']
var sources [
    array \
        $NullAudioSource \
        [AudioSource 'sys' 'system:capture_1' 'system:capture_2']
]

# Show the menu of audio sources for audio recording.
def showAudioSourceMenu {parent alternate textWidget} {
    var menu [makeMenu $parent $alternate]
    [sources iter] each source {
        menu add [source getName] [source makeAction $textWidget]
    }
}

var projectFilename 'project.crash'
var midiOutChannel [+ 0]

## Save the current project.
def saveProject {} {
    # Export all of the midi tracks to midi files.
    var i [+ 0]
    var out [open $projectFilename w]
    out write 'import [load_module /home/mmuller/w/awb/awbconfig.crash] '
    out write 'makeProject track vol pan gain midiTrack\n'
    out write 'var project [makeProject]\n'
    [getTracks] each track {
        if {track isMidi} {
            exportMidiFile [format [track getName] '.mid'] 0
            out write [format 'midiTrack ' [track getName] '.mid\n']
        } else {
            out write [format 'track ' [track getName] '\n']
        }
    }
}

def v {} 'Bring up the text panel UI.' {

    # Override builtin play, which still just starts the event manager.
    def play {} {
        [getAWBEngine] togglePlay
    }

    runUI {

        def setAudioFilename {} {
            def callback {text} {
                audioFilenameActionButton setText $text
                AudioRecorder setFilename [format $text '.wav']
            }
            EntryBar $bottomBar 1 'Audio Record Filename:' $callback $tracklist
        }

        var midiRecordingName 'midi-recording'
        [get_engine] setMidiRecordTrackName $midiRecordingName
        def setMidiRecordingName {} {
            def callback {text} {
                midiTrackNameActionButton setText $text
                set midiRecordingName $text
                [get_engine] setMidiRecordTrackName $midiRecordingName
            }
            EntryBar $bottomBar 1 'Midi Record Track name:' $callback \
                $tracklist
        }

        def setMidiOutChannel {} {
            def callback {text} {
                var newChannel [format [+ $text]]
                if {== $newChannel '0.000000'} {
                    # Need to report an error here.
                    return
                } else {
                    midiOutChannelActionButton setText $text
                    [getAWBEngine] setInputChannel $newChannel
                }
            }
            EntryBar $bottomBar 1 'Midi out channel:' $callback $tracklist
        }

        # Create a row of buttons to control midi/audio recording.
        var stateRow [Row $mainColumn 1]
        ToggleButton $stateRow 5 'Midi' $MidiRecorder
        var midiTrackNameActionButton [
            ActionButton $stateRow 16 $midiRecordingName $setMidiRecordingName
        ]
        var midiOutChannelActionButton [
            ActionButton $stateRow 4 [format $midiOutChannel] $setMidiOutChannel
        ]
        ToggleButton $stateRow 6 'Audio' $AudioRecorder
        var audioSourceButton [
            ActionButton $stateRow 8 [RecordSourceManager getCurrentName] [
                def showMenu {} {
                    showAudioSourceMenu $centerPane $tracklist \
                        $audioSourceButton
                }
            ]
        ]
        var audioFilenameActionButton [
            ActionButton $stateRow 16 'recording' $setAudioFilename
        ]

        var centerPane [Frame $mainColumn -1]

        var tracklist [TrackList $centerPane -1]
        def renameTrack {} {
            def callback {text} {
                var eng [get_engine]
                var section [eng getCurrentSection]
                var sel [tracklist getSelection]
                var track [section getTrack $sel]
                eng replaceTrack $sel [track rename $text]
            }
            EntryBar $bottomBar 1 'New name:' $callback $tracklist
        }
        tracklist bind $KEY_ENTER {
            var menu [makeMenu $centerPane $tracklist]
            menu add 'Rename track' $renameTrack
            menu add 'Do something else' [def f {} { prerr 'something else' }]
            give true
        }
        tracklist bind $KEY_DEL {
            [get_engine] deleteTrack [self getSelection]
            give true
        }
        centerPane setParcel $tracklist

        bind $KEY_SPACE play
        bind $KEY_LEFT bak
        bind $KEY_RIGHT fwd
        bind $KEY_F2 saveProject

        # Lower-case "r" to record.
        bind 114 {[get_engine] toggleRecord}

        setStatusText 'AWB -- <Space> toggle play, <q> to quit, <Left> back, <Right> Forward'

        var bottomBar [Frame $mainColumn 1]
        var timeBar [TimeBar $mainColumn 1 [getAWBEngine]]
        bottomBar setParcel $timeBar
    }
}

# Bindings for Korg Nanokontrol (channel,controller):
# << - 0,43
# >> - 0,44
# Stop - 0,42
# Play - 0,41
# Record - 0,45
# Track < - 0,58
# Track > - 0,59
