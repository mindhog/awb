
#import crack.ext._sdl SDL_Init, SDL_Event, SDL_Event_GetType, SDL_EventNew,
#    SDL_PollEvent, SDL_SetVideoMode, SDL_Quit, SDL_INIT_EVERYTHING,
#    SDL_RESIZABLE;
import crack.ascii parseInt;
import crack.cont.hashmap HashMap;
import crack.fs cwd;
import crack.functor Functor0;
import crack.lang AssertionError, CString, Exception;
import crack.cmdline CmdOptions, Option, CMD_BOOL, CMD_STR;
import crack.sys argv, exit;
import crack.time Time;
import crack.cont.array Array;
import crack.ext._sdl Surface = SDL_Surface;
import crack.game.sdl fillRect, SDLApp = App, Coord, KeyboardEvent,
    KeyboardHandler, MouseButtonEvent, MouseButtonHandler, ResizeEvent,
    ResizeHandler, SDLK_DELETE, SDLK_ESCAPE, SDLK_F2, SDLK_F5, SDLK_F7, SDLK_F8,
    SDLK_LEFT, SDLK_RETURN, SDLK_RIGHT, SDLK_TAB, SDLK_UP, SDLK_DOWN;
import crack.game.sdlgfx drawLine, drawRect, drawString, RED, BLACK, BLUE, GREEN,
    WHITE, YELLOW;
import crack.io cout, cerr, FStr;
import crack.midi.alsa Port, Queue, Sequencer, SND_SEQ_OPEN_INPUT, SND_SEQ_OPEN_OUTPUT;
import crack.midi.event merge, ChannelEvent, Event, MidiReader, MidiWriter,
    NoteOn, NoteOff, PitchWheel, ProgramChange, Track;
import crack.midi.fluidsynth FluidSettings, FluidSynth;
import crack.process Process, ProcessHandlerImpl;
import crack.strutil StringArray;
#import crack.ccl CCLInterpreter;

import spug.loop.jack WaveManager;
import spug.loop.tel telEventManager = eventManager, AppMethods, InterpWrapper;
import spug.loop.textui TextController;
import spug.loop.model programNames, ChannelMap, EventManager, Project,
    Section, Controller, IDLE, LATCHED_RECORD, PLAY, RECORD;
import spug.loop.instrument FluidSynthInstrument, Instrument, Orchestra;
import spug.ui.base Widget;
import spug.ui.piano Piano;

@import crack.ann implements, interface;

#SDL_Init(SDL_INIT_EVERYTHING);
#SDL_SetVideoMode(640, 480, 24, SDL_RESIZABLE);
#
#SDL_Event e = SDL_EventNew();
#while (true) {
#    if (SDL_PollEvent(e)) {
#        eventType := SDL_Event_GetType(e);
#        if (eventType == SDL_KEYDOWN)
#
#    }
#}
#SDL_Quit();

CmdOptions cl = [
    Option('port', 'p', 'Midi port (e.g. "20:0")', '', CMD_STR),
    Option('text', 't', 'Use text UI (not SDL)', 'false', CMD_BOOL),
];

nonFlagArgs := cl.parse(argv);
String filename;
if (nonFlagArgs.count() > 1)
    filename = nonFlagArgs[1];
else
    cout `args = $nonFlagArgs\n`;

int clientNum, portNum;
portName := cl['port'].value;
if (!portName) {
#    cerr `Usage: -p <port-name>\n`;
#    exit(1);
} else {
    cout `parsing port name\n`;
    colonPos := portName.lfind(b':');
    if (colonPos == -1) {
        cerr `Invalid port name (need device:port, do aplaymidi -l to see \
options)\n`;
        exit(1);
    }

    clientNum = parseInt(portName.slice(0, colonPos));
    portNum = parseInt(portName.slice(colonPos + 1));
}
cout `client num = $clientNum, port num = $portNum\n`;

Array[byte] MAJ_CHORD = [0, 4, 7];

Array[byte] CHORD_PRIMARIES = [57, 59, 60, 62, 64, 65, 67];
const DRUM := 9;

## Starts the piano roll window.
class StartPianoRollEvent {
    Track track;
    oper init(Track track) : track = track {}
}

# User event queue.
Array[StartPianoRollEvent] userQueue = {};

class ChordPlayer {
    SDLApp app = {640, 480};
    Instrument instrument;

    class KeyHandler : Object @implements KeyboardHandler {
        SDLApp app;
        Instrument instrument;
        oper init(SDLApp app, Instrument instrument) : app = app,
            instrument = instrument {
        }

        void playChord(byte primary, bool start) {
            if (start) {
                for (offset :in MAJ_CHORD)
                    instrument.noteOn(primary + offset, 127);
            } else {
                for (offset :in MAJ_CHORD)
                    instrument.noteOff(primary + offset);
            }
        }

        bool onKeyDown(KeyboardEvent event) {
            sym := event.sym;
            if (sym == b'q')
                app.terminate();
            else if (sym <= b'g' && sym >= b'a')
                playChord(CHORD_PRIMARIES[sym - b'a'], true);

            return true;
        }

        bool onKeyUp(KeyboardEvent event) {
            sym := event.sym;
            if (sym <= b'g' && sym >= b'a')
                playChord(CHORD_PRIMARIES[sym - b'a'], false);

            return true;
        }
    }

    oper init(Instrument instrument) : instrument = instrument {
        app.resizable = true;
        app.initialize();
        app.addKeyboardHandler(KeyHandler(app, instrument));
    }

    void run() {
        app.mainloop();
    }
}

class Button : Widget {
    CString text;

    uint32 background = 0x202020FF, foreground = WHITE;
    oper init(Coord pos, CString text) :
        Widget(pos, Coord(text.size * 8 + 2, 10)),
        text = text {
    }

    Coord getMinSize() { return size; }

    void draw(Surface surface) {
        fillRect(surface, pos, size, background);
        drawString(surface, pos + Coord(1, 1), text, foreground);
    }
}

class Panel : Widget {
    Array[Widget] widgets = {};
    Coord minSize;

    oper init(Coord pos, Coord size) : Widget(pos, size) {}
    oper init(uint size) : Widget(null, null), widgets(size) {}

    void append(Widget widget) { widgets.append(widget); minSize = null; }

    Coord getMinSize() {
        if (!minSize) {
            minSize = Coord(0, 0);
            for (child :in widgets) {
                childMin := child.getMinSize();
                minSize.x += childMin.x;
                if (childMin.y > minSize.y)
                    minSize.y = childMin.y;
            }
            minSize.x += 4 * (widgets.count() + 1);
            minSize.y += 8;
        }
        return minSize;
    }

    void draw(Surface surface) {
        drawRect(surface, pos, pos + getMinSize(), BLUE);
        int xoff;
        for (child :in widgets) {
            xoff += 5;
            child.pos = Coord(pos.x + xoff, pos.y + 5);
            xoff += child.getMinSize().x;
            child.draw(surface);
        }
    }
}

const uint32
    TRACK_BACKGROUND = 0x20202000,    # normal background is gray
    TRACK_ACTIVE = 0x400000,          # active background adds green
    TRACK_SELECTED = 0x4000,          # selected background adds blue
    POS_LINE_COLOR = RED;             # position marker line

const int CHAR_WIDTH = 8, TRACK_HEIGHT = 14;

## This class bundles up all of the state information that is known by the
## track panel so that individual tracks can draw themselves more easily.
class TrackCanvas {

    ## width of the label column to the left.
    int labelColWidth;

    ## Width of the event column to the right.
    int eventColWidth;

    ## end time of the section.
    int endTime;

    int curTime;

    Coord pos, size;

    Surface surface;

    oper init(Surface surface, Coord pos, Coord size,
              int labelColWidth,
              int eventColWidth,
              int curTime,
              int endTime
              ) :
        surface = surface,
        pos = pos,
        size = size,
        labelColWidth = labelColWidth,
        eventColWidth = eventColWidth,
        curTime = curTime,
        endTime = endTime {
    }

    void fill(uint32 color) {
        fillRect(surface, pos, size, color);
    }

    void drawLabel(String text) {
        maxLabel := labelColWidth / CHAR_WIDTH;
        drawString(surface, pos + Coord(0, (size.y - 8) / 2),
                   CString((text.size > maxLabel) ?
                            text.substr(0, maxLabel) :
                            text
                           ),
                   WHITE
                   );
    }

    uint16 __toX(uint t) {
        return uint16(t * eventColWidth / endTime + labelColWidth);
    }

    void drawNote(int startTime, int endTime, float y) {
        uint16 realY = uint16(pos.y + size.y - 1 - y * size.y);
        Coord
            a = {__toX(startTime), realY},
            b = {__toX(endTime), realY};

        drawLine(surface, a, b,
                 (curTime >= startTime && curTime < endTime) ? GREEN : YELLOW
                 );
    }
}

## Track widgets display a graphical representation of a track and its events.
class TrackWidget {
    Track model;

    ## True if the track is selected (multiple tracks can be selected)
    bool selected;

    ## True if the track is active (only one track can be active)
    bool active;

    oper init(Track model, uint endTime) :
        model = model {
    }

    void draw(TrackCanvas canvas) {
        canvas.fill(TRACK_BACKGROUND | (active ? TRACK_ACTIVE : 0) |
                     (selected ? TRACK_SELECTED : 0)
                    );
        canvas.drawLabel(model.name);

        # first determine high and low notes
        byte low = 0xff, high = 0;
        for (event :in model) {
            if (n := NoteOn.cast(event, null)) {
                high = (n.note > high) ? n.note : high;
                low = (n.note < low) ? n.note : low;
            }
        }

        # if the track only has one note, split it out so the note is in the
        # middle of the range
        if (!(high - low)) {
            if (low > 0) --low;
            if (high < 0xff) ++high;
        }

        # now draw the events as many times as it takes to fill the section
        # span
        uint frameStart, trackSpan = model[-1].time;
        while (frameStart < canvas.endTime) {
            Array[uint] startTime = {256};
            for (int i; i < 256; ++i)
                startTime.append(0);
            for (event :in model) {
                if (n := NoteOn.cast(event, null)) {
                    startTime[n.note] = n.time;
                } else if (n := NoteOff.cast(event, null)) {
                    canvas.drawNote(frameStart + startTime[n.note],
                                    frameStart + n.time,
                                    float(n.note - low) / (high - low)
                                    );
                }
            }

            frameStart += trackSpan;
        }
    }

    void activate(TrackCanvas canvas, bool active) {
        this.active = active;
        draw(canvas);
    }
}

## The channel widget shows the current channel pallete and the programs for
## each channel.
class ChannelWidget : Widget {

    ChannelMap model;
    byte lastCurrentChannel;
    Coord __size;

    uint textWidth;

    # if true, this is the active panel
    bool __active;

    Array[Button] channelButtons = {16};

    oper init(Coord pos, Coord size, ChannelMap model) :
        Widget(pos, size),
        model = model {

        # find the maximum width needed for any program name
        for (channel :in model.programs) {
            tw := programNames[model.currentChannel].size;
            if (tw > textWidth)
                textWidth = tw;
        }

        # create buttons for all of the programs
        uint xoff = 3, yoff = 3, index, xmax, buttonHeight;
        for (chi :in model.programs) {
            programName := (index == 9) ? "Drumz" :
                                          CString(chi.getProgramName());

            btn := Button(Coord(pos.x + xoff, pos.y + yoff), programName);
            buttonHeight = btn.getMinSize().y;

            # make the button for the current channel visually distinct
            if (index == model.currentChannel) {
                btn.background = BLUE;
                btn.foreground = BLACK;
                lastCurrentChannel = byte(index);
            }

            channelButtons.append(btn);
            if (++index % 4) {
                xoff += textWidth * 8;
            } else {
                yoff += btn.getMinSize().y;
                xmax = xoff;
                xoff = 3;
            }

        }

        # calculate the size
        __size = Coord(4 * textWidth * 8 + 6,
                       buttonHeight * (channelButtons.count() + 3) / 4 + 6
                       );
    }

    Coord getMinSize() { return __size; }

    void moveTo(Coord coord, Coord size) {
        Widget.moveTo(coord, size);
        uint xoff = 3, yoff = 3, index;
        for (btn :in channelButtons) {
            btn.pos = Coord(pos.x + xoff, pos.y + yoff);
            if (++index % 4) {
                xoff += textWidth * 8;
            } else {
                yoff += btn.getMinSize().y;
                xoff = 3;
            }
        }
    }

    ## activate/deactivate the window.
    void activate(Surface surface, bool newActive) {
        __active = newActive;
        drawRect(surface, pos, pos + getMinSize(), __active ? YELLOW : BLACK);
    }

    bool isActive() {
        return __active;
    }

    void draw(Surface surface) {
        activate(surface, __active);
        for (btn :in channelButtons)
            btn.draw(surface);
    }

    void onCurrentChanged(Surface surface) {
        button := channelButtons[lastCurrentChannel];
        button.background = 0x202020FF;
        button.foreground = WHITE;
        button.draw(surface);

        button = channelButtons[model.currentChannel];
        button.background = BLUE;
        button.foreground = WHITE;
        button.draw(surface);
        lastCurrentChannel = model.currentChannel;
    }

    bool onKeyPress(Surface surface, KeyboardEvent event) {
        cout `got key press, $(event.sym)\n`;
        if (event.sym == SDLK_LEFT) {
            --model.currentChannel;
            if (model.currentChannel == 0xff)
                model.currentChannel = byte(channelButtons.count() - 1);
            onCurrentChanged(surface);
        } else if (event.sym == SDLK_RIGHT) {
            ++model.currentChannel;
            if (model.currentChannel == channelButtons.count())
                model.currentChannel = 0;
            onCurrentChanged(surface);
        } else if (event.sym == SDLK_UP) {
            model.currentChannel -= 4;
            if (model.currentChannel >= 0xfc)
                model.currentChannel += 4;
            onCurrentChanged(surface);
        } else if (event.sym == SDLK_DOWN) {
            model.currentChannel += 4;
            if (model.currentChannel >= channelButtons.count())
                model.currentChannel -= byte(channelButtons.count());
            onCurrentChanged(surface);
        } else {
            return false;
        }

        return true;
    }

    void changeChannel(Surface surface, int direction) {
        model.currentChannel += byte(direction);
        if (model.currentChannel == 255)
            model.currentChannel = byte(model.programs.count() - 1);
        else if (model.currentChannel == model.programs.count())
            model.currentChannel = 0;

        onCurrentChanged(surface);
    }
}

## Widget that manages a list of TrackWidget's.
class TrackPanel : Widget {

    bool __active;
    int __activeIndex = -1;
    Array[TrackWidget] __elems = {};

    # Width of the label column.
    int __labelColWidth;

    EventManager em;

    oper init(EventManager em, Coord pos, Coord size) :
        Widget(pos, size),
        __labelColWidth = CHAR_WIDTH * 12,
        em = em {
    }

    typeof(Array[TrackWidget]().iter()) iter() { return __elems.iter(); }
    TrackWidget oper [](int index) { return __elems[index]; }
    TrackWidget oper [](uint index) { return __elems[index]; }
    void clear() { __elems.clear(); }
    uint count() { return __elems.count(); }

    void activate(Surface surface, bool newActive) {
        __active = newActive;
        drawRect(surface, pos, getBottomLeft(), __active ? YELLOW : BLACK);
    }

    bool isActive() { return __active; }

    TrackCanvas __makeTrackCanvas(Surface surface, Coord trackSize,
                                  int index
                                  ) {
        ts := trackSize ? trackSize : Coord(size.x - 1, TRACK_HEIGHT);
        Coord trackPos = {pos.x + 1, pos.y + index * TRACK_HEIGHT + 1};
        return TrackCanvas(surface, trackPos,
                           ts,
                           __labelColWidth,
                           ts.x - __labelColWidth,
                           em.lastTime % em.curSection.span,
                           em.curSection.span
                           );
    }

    void draw(Surface surface) {
        fillRect(surface, pos, size, BLACK);
        activate(surface, __active);
        int index;
        Coord trackSize = {size.x - 2, TRACK_HEIGHT};
        for (track :in this) {
            track.draw(__makeTrackCanvas(surface, trackSize, index));
            ++index;
        }
    }

    ## Add a new track, creating a new track widget.
    ## If 'surface is not null, draws the track.
    TrackWidget addTrack(Track track, uint endTime, Surface surface) {
        w := TrackWidget(track,
                         endTime
                         );
        __elems.append(w);
        __activeIndex = __elems.count() - 1;
        if (!(surface is null))
            w.draw(__makeTrackCanvas(surface, null, __activeIndex));
        return w;
    }

    void deleteActiveTrack() {
        if (__activeIndex == -1) {
            cerr `ERROR: deleteActiveTrack(): no active track\n`;
            return;
        }
        em.deleteTrack(__activeIndex);
    }

    void selectActiveTrack(Surface surface) {
        if (__activeIndex == -1) {
            cerr `ERROR: no selected track\n`;
            return;
        }
        cout `selected track $__activeIndex\n`;
        __elems[__activeIndex].selected = !__elems[__activeIndex].selected;
        __elems[__activeIndex].draw(__makeTrackCanvas(surface, null,
                                                      __activeIndex
                                                      )
                                    );
    }

    void trackDeleted(Surface surface, uint index) {
        __elems.delete(index);
        if (__elems)
            __activeIndex = (index + 1) % __elems.count();
        else
            __activeIndex = -1;
        draw(surface);
    }

    void sectionChanged() {
        __elems.clear();
        for (track :in em.curSection.tracks)
            addTrack(track, track[-1].time, null);
    }

    void drawPosition(Surface surface) {
        # find the absolute line position.
        x := __labelColWidth +
             em.getTimeFraction() * (size.x - __labelColWidth) + pos.x;
        drawLine(surface, Coord(x, pos.y), Coord(x, pos.y + size.y - 1),
                 POS_LINE_COLOR
                 );
    }

    void __activate(Surface surface, int index) {

        # if there's no tracks, quit now.
        if (!count())
            return;

        Coord trackSize = {size.x - 1, TRACK_HEIGHT};
        this[__activeIndex].activate(__makeTrackCanvas(surface, trackSize,
                                                       __activeIndex
                                                       ),
                                     false
                                     );
        this[index].activate(__makeTrackCanvas(surface, trackSize, index),
                             true
                             );
        __activeIndex = index;
    }

    bool onKeyPress(Surface surface, KeyboardEvent event) {

        if (event.sym == SDLK_DOWN) {
            __activate(surface,
                       __activeIndex + 1 >= count() ? 0 : __activeIndex + 1
                       );
        } else if (event.sym == SDLK_UP) {
            __activate(surface,
                       __activeIndex - 1 < 0 ? count() - 1 : __activeIndex - 1
                       );
        } else if (event.sym == SDLK_DELETE) {
            deleteActiveTrack();
        } else if (event.sym == b't') {
            selectActiveTrack(surface);
        } else if (event.sym == SDLK_RETURN) {
            userQueue.append(StartPianoRollEvent(this[__activeIndex].model));
        } else {
            return false;
        }

        return true;
    }

    Array[Track] getSelectedTracks() {
        Array[Track] selected = {};
        for (trackWidget :in __elems) {
            if (trackWidget.selected)
                selected.append(trackWidget.model);
        }

        return selected;
    }
}

class TextWidget : Widget {
    CString text;

    oper init(Coord pos, Coord size, CString text) :
        Widget(pos, size),
        text = text {
    }

    void setText(String text) {
        this.text = CString(text);
    }

    void setText(CString text) {
        this.text = text;
    }

    void draw(Surface surface) {
        drawRect(surface, pos, getBottomLeft(), BLACK);
        drawString(surface, pos + Coord(1, 1), text, WHITE);
    }
}

/*
    Record state machine:

        idle -> play
            begin playing from the beginning of the section
        idle -> latched record
            if the section already has events, go directly to 'record'
            on the first event, switch to 'record'
        latched record -> record
            set the offset, begin storing events.
        record -> play
            merge recorded events
            if there are no events, just go to idle.
*/

## The main application class.
class App : Object @implements AppMethods, KeyboardHandler, MouseButtonHandler,
            ResizeHandler, Controller {
    SDLApp app = {640, 480};
    EventManager eventManager;
    InterpWrapper interp;

    # the cursor that points to the next event in the merged track.  This
    # should get reset whenever we reset the start time
    typeof(Track('').iter()) trackCursor;

    # when using the QWERTY keyboard as a controller, this is midi note value
    # of the lowest note.
    byte inputOffset = 40;

    Button
        playBtn = {Coord(10, 10), 'play'},
        recBtn = {Coord(80, 10), 'record'};
    Panel panel;

    ChannelWidget channelWidget;
    TextWidget statusBar;
    TrackPanel trackPanel;
    Array[Widget] panels = {};

    ## Key bindings.   Keys are specified as SDL constants
    HashMap[int, Functor0[void]] bindings = {};

    Piano piano;

    void setPlayBtn(bool enabled) {
        if (enabled) {
            playBtn.background = GREEN;
            playBtn.foreground = 0xFF;
        } else {
            playBtn.background = 0x202020FF;
            playBtn.foreground = WHITE;
        }
        playBtn.draw(app.surface);
    }

    void setRecBtn(bool enabled) {
        if (enabled) {
            recBtn.foreground = 0xFF;
            recBtn.background = RED;
        } else {
            recBtn.foreground = WHITE;
            recBtn.background = 0x202020FF;
        }
        recBtn.draw(app.surface);
    }

    void changeState(int oldMode, int newMode) {
        if (oldMode == newMode)
            return;

        if (oldMode == PLAY)
            setPlayBtn(false);
        else if (oldMode == RECORD)
            setRecBtn(false);

        if (newMode == RECORD)
            setRecBtn(true);
        else if (newMode == PLAY)
            setPlayBtn(true);

        app.flip();
    }

    void trackAdded() {
        trackPanel.addTrack(eventManager.curSection.tracks[-1],
                            eventManager.curSection.span,
                            null
                            );
        app.flip();
    }

    void trackDeleted(uint index) {
        trackPanel.trackDeleted(app.surface, index);
        app.flip();
    }

    void sectionCreated() {
        # XXX don't care about this until we've got a section panel.
    }

    void sectionChanged() {
        trackPanel.sectionChanged();
        trackPanel.draw(app.surface);
        app.flip();
    }

    void repaint() {
        fillRect(app.surface, Coord(0, 0), Coord(app.width, app.height),
                 BLACK
                 );
        panel.draw(app.surface);

        if (piano) {
            piano.draw(app.surface);
        } else {
            trackPanel.draw(app.surface);
            channelWidget.draw(app.surface);
        }
        statusBar.draw(app.surface);

        app.flip();
    }

    bool onKeyDown(KeyboardEvent event) {
        sym := event.sym;
        for (p :in panels) {
            if (p.isActive() && p.onKeyPress(app.surface, event)) {
                app.flip();
                return true;
            }
        }

        # See if there's a binding.
        if (handler := bindings.get(sym)) {
            handler();
            return true;
        }

        if (sym == b'q')
            app.terminate();
        else if (sym == b'r') {
            eventManager.doLatchedRecord();
        } else if (sym == b'i') {
            eventManager.doRecord();
        } else if (sym == b' ') {
            eventManager.togglePlay();
        } else if (sym == b'c') {
            eventManager.clear();
        } else if (sym == b's') {
            eventManager.doIdle();
        } else if (sym == b'l') {
            channelWidget.changeChannel(app.surface, +1);
            app.flip();
        } else if (sym == b'h') {
            channelWidget.changeChannel(app.surface, -1);
            app.flip();
        } else if (sym >= b'0' && sym <= b'9') {
            # add an input event.
            byte note = byte(sym - b'0' + inputOffset);
            eventManager.onInputEvent(NoteOn(0, DRUM, note, 127));
        } else if (sym == b'=') {
            inputOffset += 10;
        } else if (sym == b'-') {
            inputOffset -= 10;
        } else if (sym == SDLK_TAB && !piano) {

            # find the active widget.
            int i;
            Widget p;
            for (p in panels) {
                if (p.isActive()) {
                    break;
                }
                ++i;
            }

            # store the current (last) active widget, find the next one.
            last := p;
            if (++i >= panels.count())
                i = 0;
            next := panels[i];

            # change the active one, update the display.
            last.activate(app.surface, false);
            next.activate(app.surface, true);
            app.flip();
            return true;
        } else if (sym == SDLK_F2) {
            eventManager.save();
        } else if (sym == SDLK_F5) {
            # create new section
            eventManager.createSection(trackPanel.getSelectedTracks());
        } else if (sym == SDLK_F7) {
            # previous section
            int index = eventManager.getNextSectionIndex();
            int count = eventManager.getSectionCount();
            eventManager.setNextSection((count + index - 1) % count);
        } else if (sym == SDLK_F8) {
            # next section
            int index = eventManager.getNextSectionIndex();
            int count = eventManager.getSectionCount();
            eventManager.setNextSection((index + 1) % count);
        } else if (sym == SDLK_ESCAPE && piano) {
            panels.delete(-1);
            panels[0].activate(app.surface, true);
            piano = null;
            repaint();
        }

        return true;
    }

    bool onKeyUp(KeyboardEvent event) {
        sym := event.sym;

        if (sym >= b'0' && sym <= b'9') {
            # add a drum event
            byte note = byte(sym - b'0' + inputOffset);
            eventManager.onInputEvent(NoteOff(0, DRUM, note, 0));
        } else if (sym == b'=') {
            byte note = ++inputOffset;
            eventManager.onInputEvent(NoteOff(0, DRUM, note, 127));
        }

        return true;
    }

    bool onMouseButtonDown(MouseButtonEvent event) {
        cout `down $(event.button), $(event.state), $(event.x), $(event.y)\n`;
        return true;
    }

    bool onMouseButtonUp(MouseButtonEvent event) {
        cout `up $(event.button), $(event.state), $(event.x), $(event.y)\n`;
        return true;
    }

    bool onResize(ResizeEvent event) {
        channelWidget.moveTo(Coord(0, app.height - 48),
                             Coord(app.width, 40)
                             );
        ypos := panel.getMinSize().y + 4;
        trackPanel.moveTo(Coord(0, ypos),
                          Coord(app.width,
                                app.height - 48 - ypos
                                )
                          );
        statusBar.moveTo(Coord(0, app.height - 8),
                         Coord(app.width, 8)
                         );
        if (piano)
            piano.moveTo(Coord(0, 8), Coord(0, app.height - 16));
        repaint();
        return true;
    }

    # AppMethods interface.
    void setBinding(int key, Functor0[void] callback) {
        bindings[key] = callback;
    }

    void setInterp(InterpWrapper wrapper) {
        interp = wrapper;
    }

    oper init(ChannelMap channelMap) {

        app.resizable = true;
        app.initialize();
        app.addKeyboardHandler(this);
        app.addMouseButtonHandler(this);

        panel = Panel(Coord(0, 0), Coord(app.width, 8));
        panel.append(playBtn);
        panel.append(recBtn);

        ypos := panel.getMinSize().y + 4;
        trackPanel = TrackPanel(null,
                                Coord(0, ypos),
                                Coord(app.width,
                                      app.height - 48 - ypos
                                      )
                                );
        panels.append(trackPanel);

        channelWidget = ChannelWidget(Coord(0, app.height - 48),
                                      Coord(app.width, 40),
                                      channelMap
                                      );
        channelWidget.activate(app.surface, true);
        panels.append(channelWidget);

        # we don't add the status bar to the panels because we don't want to
        # tab through it.
        statusBar = TextWidget(Coord(0, app.height - 8),
                               Coord(app.width, 8),
                               'AWB'
                               );
        statusBar.activate(app.surface, true);

        repaint();

        app.addResizeHandler(this);
    }

    void setEventManager(EventManager em) {
        trackPanel.em = em;
        eventManager = em;
    }

    ## Run the application until the user quits.
    void run() {
        if (!eventManager)
            throw AssertionError('Event manager not defined!');

        Event lastPlayed;

        while (app.isActive()) {
            try {
                app.runOneCycle();
                eventManager.runOneCycle();
                interp.checkForInput();
                while (userQueue) {
                    StartPianoRollEvent event = userQueue.pop();

                    # Put the piano roll over where the track panel and
                    # chanel widget are.
                    piano = Piano(Coord(0, 8),
                                  Coord(app.width, app.height - 16),
                                  event.track
                                  );
                    panels.append(piano);

                    # Deactivate the currently active panel.
                    for (p :in panels) {
                        if (p.isActive()) {
                            p.activate(app.surface, false);
                            break;
                        }
                    }

                    # Activate and draw the piano.
                    piano.activate(app.surface, true);
                    piano.draw(app.surface);
                    app.flip();
                }
                if (eventManager.playingExistingTracks()) {
                    trackPanel.draw(app.surface);
                    trackPanel.drawPosition(app.surface);
                    app.flip();
                }
            } catch (Exception ex) {
                cerr `Got Exception:\n$ex\n`;
            }
        }
    }
}

Sequencer s = {SND_SEQ_OPEN_INPUT | SND_SEQ_OPEN_OUTPUT, 0};
s.seq.set_client_name('AWB'.buffer);
port := s.makeWritePort('in');
outPort := s.makeReadPort('out');

# If the user specified a port to connect from on the command line, connect
# it.
if (clientNum)
    port.connectTo(clientNum, portNum);

cout `creating wave manager\n`;
waveMan := WaveManager.create();

cout `creating fluid synth\n`;
FluidSynth synth = {FluidSettings()};
synth.loadFont('/usr/share/sounds/sf2/FluidR3_GM.sf2', true);

Orchestra orch = [
    FluidSynthInstrument(synth, 0),
    FluidSynthInstrument(synth, 1),
    FluidSynthInstrument(synth, 2),
    FluidSynthInstrument(synth, 3),
    FluidSynthInstrument(synth, 4),
    FluidSynthInstrument(synth, 5),
    FluidSynthInstrument(synth, 6),
    FluidSynthInstrument(synth, 7),
    FluidSynthInstrument(synth, 8),
    FluidSynthInstrument(synth, 9),
    FluidSynthInstrument(synth, 10),
    FluidSynthInstrument(synth, 11),
    FluidSynthInstrument(synth, 12),
    FluidSynthInstrument(synth, 13),
    FluidSynthInstrument(synth, 14),
    FluidSynthInstrument(synth, 15)
];

piano := orch.getChild(0);
piano.noteOn(44, 127);
import crack.runtime sleep;
sleep(1);
piano.noteOff(44);

# Running a process here for some reason zombifies the fluidsynth event
# thread, so let's not do that.
#cerr `starting process\n`;
#Process(StringArray!['./connect']).run(ProcessHandlerImpl());

channelMap := ChannelMap();
App app;
InterpWrapper interp;
TextController textui;
Controller controller;
if (!cl.getBool('text')) {
    controller = app = App(channelMap);
    interp = InterpWrapper(app);
    app.setInterp(interp);
} else {
    controller = textui = TextController();
    interp = InterpWrapper(textui);
    textui.setInterp(interp);
}
cout `creating event manager\n`;
EventManager em = {controller, orch, s, channelMap};
em.waveMan = waveMan;
telEventManager = em;
if (app)
    app.setEventManager(em);

String projectFile;
for (arg :in nonFlagArgs.subarray(1)) {
    if (arg.endsWith('.awb')) {
        cout `loading awb project $arg\n`;
        if (projectFile)
            cout `WARNING: Overwriting existing project from $projectFile\n`;
        projectFile = arg;
        em.load(arg);
    } else if (arg.endsWith('.crash')) {
        cout `running script $arg\n`;
        try {
            interp.evalScript(arg);
        } catch (Exception ex) {
            cerr `Got exception:\n$ex\n`;
            exit(1);
        }
    } else if (arg.endsWith('.wav')) {
        em.mapWaveFile(arg);
    } else {
        cout `ERROR: file with unknown extension: $arg\n`;
    }
}

cout `running\n`;
if (app)
    app.run();
else
    textui.run();

waveMan.deactivate();

#Sequencer s = {SND_SEQ_OPEN_OUTPUT, 0};
#port := s.makeReadPort(CString('Crack Port'));
#port.connectTo(clientNum, portNum);

#cout `creating fluid synth\n`;
#FluidSynth synth = {FluidSettings()};
#synth.loadFont('/usr/share/sounds/sf2/FluidR3_GM.sf2', true);
#cout `creating player\n`;
#ChordPlayer player = {FluidSynthInstrument(synth, 0)};
#cout `running\n`;
#player.run();
