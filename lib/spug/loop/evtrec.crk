## The event recorder module.

import crack.cont.array Array;
import crack.cont.treemap TreeMap;
import crack.fs makePath, Path;
import crack.functor Functor2;
import crack.io cerr, Formatter, FStr, StandardFormatter;
import crack.lang Exception, StaticString;
import crack.midi.event ChannelEvent, ControlChange, Event;
import crash parseBlockArg, Block, Builtin, EvalContext, Obj;
import spug.loop.model EventContext, EventManager;
import spug.loop.jack WaveManager, WindowBufferAdapter;
import types BoolObj, FloatObj, IntObj;
import .plugins PluginInstance, PluginLibrary;
import .plugincmds makeEffectObj;

@import ann function;
@import crack.ann cvars, impl;

alias EventProcessor = Functor2[void, Event, EventContext];

class Panner @impl EventProcessor {
    WindowBufferAdapter adapter;
    WaveManager waveMan;
    Formatter out;
    int track;
    oper init(WindowBufferAdapter adapter, WaveManager waveMan,
              Formatter out,
              int track
              ) :
        adapter = adapter,
        waveMan = waveMan,
        out = out,
        track = track {
    }
    void oper call(Event event, EventContext ctx) {
        adapter.setPan(pan := ControlChange.cast(event).value / 64.0 - 1.0);
        out I`forward $(waveMan.tell())
              pan $track $(pan)
              `;
    }
}

class VolumeControl @impl EventProcessor {
    WindowBufferAdapter adapter;
    WaveManager waveMan;
    Formatter out;
    int track;
    oper init(WindowBufferAdapter adapter, WaveManager waveMan,
              Formatter out,
              int track
              ) :
        adapter = adapter,
        waveMan = waveMan,
        out = out,
        track = track {
    }
    void oper call(Event event, EventContext ctx) {
        adapter.mixer.volume = float(ControlChange.cast(event).value) / 128.0;
        # TODO: only want to see the last of these for a given time position
        out I`forward $(waveMan.tell())
              volume $track $(adapter.mixer.volume)
              `;
    }
}

## Returns the event classname.
@function(Event) String Event_type() {
    return StaticString(self.class.name);
}

## Returns the channel (the event must be a ChannelEvent, specifically one of
## NoteOn, NoteOff, ProgramChange, PitchWheel, or ControlChange).
@function(Event) int Event_channel() {
    return ChannelEvent.cast(self).channel;
}

## Returns the controller (the event must be a ControlChange event).
@function(Event) int Event_controller() {
    return ControlChange.cast(self).controller;
}

## Returns the controller value (the event must be a ControlChange event).
@function(Event) int Event_value() {
    return ControlChange.cast(self).value;
}

Obj wrapEvent(Event event) {
    result := Obj();
    result.define('type', Event_type(event));
    result.define('channel', Event_channel(event));
    result.define('controller', Event_controller(event));
    result.define('value', Event_value(event));
    return result;
}

## An event processor that invokes a crash script.
class ScriptProcessor @impl EventProcessor {
    @cvars {
        EvalContext context;
        Block block;
    }

    void oper call(Event event, EventContext ctx) {
        context.pushFuncFrame();
        try {
            context.define('event', wrapEvent(event));
            block.evaluate(context);
        } catch (Exception ex) {
            cerr `Got exception in event handler script: $ex\n`;
        }
        context.popFuncFrame();
        cerr `terminating from script processor\n`;
    }
}

## A representation of a project, which is a base directory containing a bunch
## of synchronized wave files and into which an output logfile is written,
## describing all of the mixer events for the project.
class Project {
    EventManager eventManager;
    Path dir;

    ## The output logfile.
    Formatter out;

    ## The next track index.
    int __trackIndex;

    PluginLibrary __plugins = {};

    Array[WindowBufferAdapter] __channels = {};

    oper init(EventManager eventManager, String dir) :
        eventManager = eventManager,
        dir = makePath(dir) {

        # Rather than blindly overwriting this, we should probably load it in
        # a crash context that nerfs most of the commands except for the
        # "load" commands.
        out = StandardFormatter((this.dir/'logfile.crash').writer());
    }

    ## Adds a track given the name of a wave file.
    void addTrack(String filename, int volumeController, int panController) {
        if (!eventManager.waveMan)
            eventManager.waveMan = WaveManager.create();
        adapter := eventManager.mapWaveFile((dir/filename).getFullName());

        eventManager.eventProcessors[panController] =
            Panner(adapter, eventManager.waveMan, out, __trackIndex);
        eventManager.eventProcessors[volumeController] =
            VolumeControl(adapter, eventManager.waveMan,  out, __trackIndex);

        ++__trackIndex;
        __channels.append(adapter);

        # Add the new track to the log.
        out `load $(dir/filename)\n`;
    }

    ## Write 'text' to the logfile.  Note that this does not add a newline,
    ## you'll want to provide that.
    void writeLog(String text) {
        out.write(text);
    }

    ## Set the gain for the channel at the index.
    void setGain(int index, float gain) {
        __channels[index].mixer.gain = gain;
        out `gain $index $gain\n`;
    }

    ## Set the volume for the channel at the index.
    void setVol(int index, float volume) {
        __channels[index].mixer.volume = volume;
        out `volume $index $volume\n`;
    }

    ## Set the pan for the channel at the index.
    void setPan(int index, float pan) {
        __channels[index].setPan(pan);
        out `pan $index $pan\n`;
    }

    ## Enable or diable the channel.
    void setEnabled(int index, bool enabled) {
        if (enabled)
            __channels[index].enable();
        else
            __channels[index].disable();
    }

    ## Returns true if the channel is enabled.
    bool getEnabled(int index) {
        return __channels[index].enabled();
    }

    PluginInstance insertEffect(int index, String pluginName) {
        plugin := __plugins.getPluginByName(pluginName);
        if (!plugin)
            throw Exception(FStr() `Unknown plugin $(pluginName.getRepr())`);
        # TODO: need to get the rate from somewhere in the system.
        inst := plugin.makeInstance(44100);
        __channels[index].insertComponent(inst);
        return inst;
    }

    ## Bind an arbitrary controller event to an event processor.
    ## As elsewhere, 'controller' is an integer in which the low-byte is the
    ## controller id and the high-byte is the channel number.
    void bindController(int controller, EventProcessor processor) {
        eventManager.eventProcessors[controller] = processor;
    }
}

@function(Project) int Project_addTrack(String filename, int panController,
                                        int volumeController
                                        ) {
    self.addTrack(filename, panController, volumeController);
    return 0;
}

@function(Project) int Project_setGain(int index, float gain) {
    self.setGain(index, gain);
    return 0;
}

@function(Project) int Project_setPan(int index, float pan) {
    self.setPan(index, pan);
    return 0;
}

@function(Project) Obj Project_insertEffect(int index, String pluginName) {
    return makeEffectObj(self.insertEffect(index, pluginName));
}

class Project_bindControllerScriptCmd : Builtin {
    @cvars{
        Project proj;
    }

    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 2)
            throw Exception('Accepts exactly two arguments');
        proj.bindController(IntObj.convert(args[0]).val,
                            ScriptProcessor(context, parseBlockArg(args, 1))
                            );
        return IntObj(0);
    }
}

@function(Project) int Project_setVol(int index, float volume) {
    if (volume > 1)
        volume = 1;
    else if (volume < -1)
        volume = -1;
    self.setVol(index, volume);
    return 0;
}

@function(Project) int Project_writeLog(String text) {
    self.writeLog(text);
    return 0;
}

@function(Project) int Project_setEnabled(int index, bool enabled) {
    self.setEnabled(index, enabled);
    return 0;
}

@function(Project) bool Project_getEnabled(int index) {
    return self.getEnabled(index);
}

class EventRecorderModule {
    EventManager eventManager;
    oper init(EventManager eventManager) : eventManager = eventManager {}
}

## Create a new EventRecorderModule for crash.  This lets us inject the event
## manager.
Obj makeEventRecorderModule(EventManager eventManager) {
    obj := Obj();
    erm := EventRecorderModule(eventManager);

    ## Create a new project object in the given directory.
    @function(EventRecorderModule) Obj makeProject(String dir) {
        obj := Obj();
        proj := Project(self.eventManager, dir);
        obj.define('addTrack', Project_addTrack(proj));
        obj.define('setGain', Project_setGain(proj));
        obj.define('setPan', Project_setPan(proj));
        obj.define('setVol', Project_setVol(proj));
        obj.define('writeLog', Project_writeLog(proj));
        obj.define('insertEffect', Project_insertEffect(proj));
        obj.define('bindControllerScript',
                   Project_bindControllerScriptCmd(proj)
                   );
        obj.define('setEnabled', Project_setEnabled(proj));
        obj.define('getEnabled', Project_getEnabled(proj));
        cerr `makeProject() -> $(obj.vars)\n`;
        return obj;
    }

    cerr `adding a project object\n`;
    obj.define('Project', makeProject(erm));
    return obj;
}
