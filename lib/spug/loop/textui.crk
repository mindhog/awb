
import crack.cont.array Array;
import crack.cont.hashmap HashMap;
import crack.exp.termui Event, KeyEvent, TermApp, Window, KEY_UP, KEY_DOWN,
    KEY_LEFT, KEY_RIGHT, KEY_PGUP, KEY_PGDN, KEY_BACKSPACE, KEY_ENTER,
    KEY_ESC, KEY_SPACE;
import crack.functor Functor0, Functor1;
import crack.io cerr, cout, FStr, StandardFormatter, StringFormatter;
import crack.lang Exception;
import crack.net Poller;
import crack.net.pollqueue PollQueue;
import crash createRootContext, eval, parseString, Builtin, EvalContext,
    Obj, ObjOf, SimpleValue;
import deadly.layout Column, Container, Row;
import deadly.termlist List;
import repl repl;
import .model Controller;
import .midieng MidiEngine, TimeCallback, TimeEvent;
import .tel eventManager, AppMethods, CrashCallback, InterpWrapper;

import types FloatObj, IntObj;
@import ann function;

@import crack.ann cvars, impl, implements, interface;

class AppContext {}

alias BindingMap = HashMap[int, Functor1[bool, AppContext]];

BindingMap appBindings = BindingMap();

class App : TermApp {
    AppContext __context;

    oper init(AppContext context) : __context = context {}

    void onEvent(Event event) {
        if (ke := KeyEvent.cast(event, null)) {
            if ((cb := appBindings.get(ke.key)) && cb(__context))
                return;
            else if (ke.key == b'q')
                terminate();
        }

        TermApp.onEvent(event);
    }
}

class Status : Window {

    byte normalAttr = 7;
    String text = 'AWB';

    oper init(Window parent) : Window(parent) {}

    void paint() {
        gc := getGraphicsContext();
        gc.fillRect(0, 0, width, height, normalAttr, b' ');
        gc.write(0, 0, normalAttr, text);
    }
}

class TrackList : List {
    @final void reloadTracks() {
        model = Array[String]();
        for (track :in eventManager.curSection.tracks)
            model.append(track.name);
    }

    oper init(Window parent) : List(parent, Array[String]()) {
        reloadTracks();
    }

    void trackAdded() {
        model.append(eventManager.curSection.tracks[-1].name);
    }

    void waveAdded() {
        model.append(eventManager.curSection.waves[-1].getName());
    }

    void trackDeleted() {
        reloadTracks();
    }
}

## The BarSlider is a horizontal single bar graph window that displays two
## ranges: the value range (using the value attribute, red by default) and
## the controller range (using the controller attribute, blue by default).
## If the two values are equal they are displayed in the sync attribute
## (green by default).
class BarSlider : Window {

    float __value, __controller;
    byte backgroundAttr = 0,
        valueAttr = 0x10,
        controllerAttr = 0x40,
        syncAttr = 0x20;

    oper init(Window parent) : Window(parent) {}

    float oper .value=(float value) { return __value = value }
    float oper .controller=(float controller) {
        return __controller = controller;
    }

    void paint() {
        gc := getGraphicsContext();
        gc.fillRect(0, 0, width, height, backgroundAttr, b' ');

        # Paint the bars from largest to smallest so that we
        if (__value == __controller) {
            gc.fillRect(0, 0, int(__value * width), height, syncAttr, b' ');
        } else if (__value < __controller) {
            gc.fillRect(0, 0, int(__controller * width), height,
                        controllerAttr,
                        b' '
                        );
            gc.fillRect(0, 0, int(__value * width), height, valueAttr, b' ');
        } else {
            gc.fillRect(0, 0, int(__value * width), height, valueAttr, b' ');
            gc.fillRect(0, 0, int(__controller * width), height,
                        controllerAttr,
                        b' '
                        );
        }
    }
}

@function Obj makeBarSlider(Window parent, int size) {
    @function(BarSlider) float setValue(float value) {
        self.value = value;
        return value;
    }

    @function(BarSlider) float setController(float controller) {
        self.controller = controller;
        return controller;
    }

    self := BarSlider(parent);
    if (container := Container.cast(parent, null))
        container.addChild(self, size);
    result := ObjOf[BarSlider](self);
    result.define('setValue', setValue(self));
    result.define('setController', setController(self));
    return result;
}

## A message sent to the text controller with "send()".  These can be used to
## safely make changes to textui objects from other threads.
@interface Message {
    @abstract void run();
}

alias MessageQueue = PollQueue[Message];

class TimeBar : Window {

    byte normalAttr = 7;

    uint time;

    void onTimeEvent(TimeEvent event);

    class TimeMessage @impl Message {
        @cvars {
            TimeBar timeBar;
            TimeEvent event;
        }

        void run() { timeBar.onTimeEvent(event) }
    }

    class MyTimeCallback @impl TimeCallback {
        @cvars {
            TimeBar timeBar;
            MessageQueue __queue;
        }

        void oper call(TimeEvent event) {
            __queue.add(TimeMessage(timeBar, event));
        }
    }

    oper init(Window parent) : Window(parent) {}

    @static TimeBar create(Window parent, MessageQueue queue,
                           MidiEngine midiEng) {
        result := TimeBar(parent);
        midiEng.subscribeTimeEvent(MyTimeCallback(result, queue));
        return result;
    }

    void paint() {
        gc := getGraphicsContext();
        gc.fillRect(0, 0, width, height, normalAttr, b' ');
        gc.write(0, 0, normalAttr, FStr() `$time`);
    }

    void onTimeEvent(TimeEvent event) {
        time = uint(event.usecs / 1000);
    }
}

class CallbackWrapper @impl Functor1[bool, AppContext] {
    @cvars {
        Functor0[void] callback;
    }
    bool oper call(AppContext ctx) {
        callback();
        return true;
    }
}

alias MQCallback = MessageQueue.Callback;

class TextController : Object @implements Controller, AppMethods {
    InterpWrapper __interp;

    ## List of track list windows.
    Array[TrackList] __trackLists = {};

    ## The app.
    App __app;

    ## The status bar.
    Status __status;

    ## The poller for the UI.
    Poller __poller = Poller();

    ## The messge queue for communicating with UI components.
    MessageQueue __controlQueue;

    @static void __processMessage(Message message) {
        message.run();
    }

    oper init() {
        __controlQueue =
            MessageQueue(MessageQueue.Callback.Wrap(__processMessage));
        __controlQueue.addTo(__poller);
    }

    void changeState(int oldState, int newState) {
        cout `Changing state from $oldState to $newState\n`;
    }

    void trackAdded() {
        for (tl :in __trackLists)
            tl.trackAdded();
    }

    void waveAdded() {
        for (tl :in __trackLists)
            tl.waveAdded();
    }

    void trackDeleted(uint index) {
        for (tl :in __trackLists)
            tl.trackDeleted();
    }

    void sectionCreated() {
        cout `section created\n`;
    }

    void sectionChanged() {
        cout `section changed\n`;
    }

    void setBinding(int key, Functor0[void] callback) {
        appBindings[key] = CallbackWrapper(callback);
    }

    void setInterp(InterpWrapper interp) {

        ## Run the user interface.
        ##
        ## 'block' is a crash block to execute in a subcontext that exists for
        ## the duration of the time that the user interface is running.
        @function(TextController) int runUI(String block) {
            self.__app = App(AppContext());
            self.__app.showCursor(false);
            self.__app.start();
            col := Column(self.__app);
            self.__status = Status(col);
            col.addChild(self.__status, 1);

            StandardFormatter tempOut = cout, tempErr = cerr;
            cout = StringFormatter();
            cerr = StringFormatter();

            rootCtx := self.__interp.getRootContext();
            Exception error;
            try {
                rootCtx.define('mainColumn', SimpleValue(col));
                rootCtx.pushFuncFrame();
                eval(block, rootCtx);
                self.__app.run(self.__poller);
            } catch (Exception ex) {
                error = ex;
            }

            cout = tempOut;
            cerr = tempErr;

            rootCtx.popFuncFrame();
            self.__trackLists.clear();
            self.__app.showCursor(true);
            self.__app.stop();
            self.__status = null;
            self.__app = null;

            if (error)
                cerr `$error\n`;
            return 0;
        }

        @function(TextController)
        TrackList makeTrackList(Window parent, int size) {
            list := TrackList(parent);
            if (cont := Container.cast(parent, null))
                cont.addChild(list, size);
            self.__trackLists.append(list);
            return list;
        }

        @function(TextController)
        TimeBar makeTimeBar(Window parent, int size,
                            MidiEngine midiEng
                            ) {
            timeBar := TimeBar.create(parent, self.__controlQueue, midiEng);
            if (cont := Container.cast(parent, null))
                cont.addChild(timeBar, size);
            return timeBar;
        }

        @function(TextController)
        int setStatusText(String text) {
            if (self.__status)
                self.__status.text = text;
            return 0;
        }

        @function(TextController)
        int terminate() {
            self.__app.terminate();
            return 0;
        }

        @function(InterpWrapper) int bind(int key, String command) {
            appBindings[key] = CallbackWrapper(
                CrashCallback(self.getRootContext(), parseString(command))
            );
            return 0;
        }

        ## Returns the ascii character number for the first character in 'name'
        @function int char(String name) {
            if (!name)
                throw Exception('Key name must not be null or empty.');
            return name[0];
        }

        SimpleValue ival(int value) {
            return SimpleValue(IntObj(value));
        }

        __interp = interp;
        __interp.define('runUI', runUI(this));
        __interp.define('TrackList', makeTrackList(this));
        __interp.define('TimeBar', makeTimeBar(this));
        __interp.define('BarSlider', makeBarSlider());
        __interp.define('setStatusText', setStatusText(this));
        __interp.define('terminate', terminate(this));
        __interp.define('bind', bind(__interp));
        __interp.define('char', char());
        __interp.define('KEY_UP', ival(KEY_UP));
        __interp.define('KEY_DOWN', ival(KEY_DOWN));
        __interp.define('KEY_LEFT', ival(KEY_LEFT));
        __interp.define('KEY_RIGHT', ival(KEY_RIGHT));
        __interp.define('KEY_PGUP', ival(KEY_PGUP));
        __interp.define('KEY_PGDN', ival(KEY_PGDN));
        __interp.define('KEY_BACKSPACE', ival(KEY_BACKSPACE));
        __interp.define('KEY_ENTER', ival(KEY_ENTER));
        __interp.define('KEY_ESC', ival(KEY_ESC));
        __interp.define('KEY_SPACE', ival(KEY_SPACE));
    }

    void run() {
        __interp.doREPL();
    }
}
