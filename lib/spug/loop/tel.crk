## Crash interface for AWB.  This is named "tel" for historical reasons - it
## used to provide the interface to the "TEL" language, an early predecessor
## to Crash.

import crack.cont.array Array;
import crack.fs makePath;
import crack.functor Functor0, Functor1;
import crack.lang CString, Exception;
import crack.net Poller, POLLIN, POLLERR, POLLOUT;
import crack.io cin, cout, cerr, FStr;
import crack.midi.event ControlChange, Event, NoteOn, NoteOff, Track;
import crack.time TimeDelta;
import spug.loop.evtrec makeEventRecorderModule;
import spug.loop.model EventManager;
import spug.loop.instrument MidiInstrument;
import spug.loop.jack jackCallback, WaveManager, WindowBufferAdapter;

import crash createRootContext, eval, parseBlockArg, ActiveFunc, Block, Builtin,
    EvalContext, Obj;
import stdlib stdlib;
import types IntObj;

@import crack.ann assert, impl, interface;
@import ann function;

EventManager eventManager;

@function int play() {
    eventManager.togglePlay();
    return 0;
}

@function int get_tempo() {
    return eventManager.tempo;
}

@function int set_tempo(int tempo) {
    eventManager.tempo = tempo;
    return 0;
}

@function int metro(int beats) {
    metroTrack := Track('Metronome');
    metroTrack.append(NoteOn(0, 9, 31, 127));
    metroTrack.append(NoteOff(1, 9, 31, 0));

    int i;
    for (i = 1; i < beats; ++i) {
        metroTrack.append(NoteOn(i * eventManager.ppb, 9, 33, 127));
        metroTrack.append(NoteOff(i * eventManager.ppb + 1, 9, 33, 127));
    }

    eventManager.addTrack(metroTrack, i * eventManager.ppb);
    return 0;
}

@function WindowBufferAdapter load(String filename) {
    if (!eventManager.waveMan)
        eventManager.waveMan = WaveManager.create();
    return eventManager.mapWaveFile(filename);
}

@function int channelConnect(int channel, int client, int port) {
    inst := MidiInstrument(eventManager.getOutPort(client, port), byte(channel));
    eventManager.instrument[channel] = inst;
    return 0;
}

@function int connect(String source, String dest) {
    if (eventManager.waveMan)
        eventManager.waveMan.connect(CString(source), CString(dest));
    return 0;
}

@function int Ev_getValue(Event event) {
    return ControlChange.cast(event).value;
}

alias EventProcessor = Functor1[void, Event];

class VolumeControl @impl EventProcessor {
    WindowBufferAdapter adapter;

    oper init(WindowBufferAdapter adapter) : adapter = adapter {}

    void oper call(Event event) {
        adapter.volume = ControlChange.cast(event).value / 128.0;
        cout `changing volume of $adapter to $(adapter.volume)\n`;
    }
}

@function EventProcessor volumeControl(WindowBufferAdapter adapter) {
    return VolumeControl(adapter);
}

## Set the volume from a value from 0 to 127.
@function int setVolume(WindowBufferAdapter adapter, int volume) {
    adapter.volume = float(volume) / 128.0;
    cout `volume set to $(adapter.volume)\n`;
    return 0;
}

class PanControl @impl EventProcessor {
    WindowBufferAdapter adapter;

    oper init(WindowBufferAdapter adapter) : adapter = adapter {}

    void oper call(Event event) {
        pan := ControlChange.cast(event).value / 64.0 - 1.0;
        adapter.setPan(pan);
        cout `changing panning of $adapter to $pan\n`;
    }
}

@function EventProcessor panControl(WindowBufferAdapter adapter) {
    return PanControl(adapter);
}

## Set the channel pan from -32k to 32k.
@function int setPan(WindowBufferAdapter adapter, int pan) {
    # TODO: This appears to be completely wrong, setPan() accepts a float from
    # -1 to +1.
    adapter.setPan(pan);
    return 0;
}

## Event processor that can run a crash script.
class CrashScriptEventProcessor @impl EventProcessor {
    EvalContext __context;
    ActiveFunc __func;

    oper init(EvalContext context, ActiveFunc func) :
        __context = context,
        __func = func {
    }

    void oper call(Event event) {
        try {
            __func.invoke(__context, Array[Object]![event]);
        } catch (Exception ex) {
            cerr `Exception caught by event dispatcher:\n$ex\n`;
        }
    }
}

## CrashEventProcessor <crash-func>
##
## Creates an event processor from a crash function.
class CrashEventProcessorCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Accepts only one argument');
        func := ActiveFunc.cast(args[0], null);
        if (!func)
            throw Exception('Argument must be a function');
        return CrashScriptEventProcessor(EvalContext(context), func);
    }
}

@function int addEventProcessor(int eventSelector, EventProcessor processor) {
    Object o = processor;
    eventManager.eventProcessors[eventSelector] = processor;
    cout `event processor's ref count is $(o.refCount)\n`;
    return 0;
}

@function int seek(int pos) {
    if (!eventManager.waveMan)
        return -1;

    eventManager.waveMan.seek(pos);
    return 0;
}

@function int tell() {
    return eventManager.waveMan.tell();
}

## Skip forward one second.
@function int bak() {
    if (!eventManager.waveMan)
        return -1;

    pos := eventManager.waveMan.tell();
    if (pos < 44100)
        return -2;

    eventManager.waveMan.seek(pos - 44100);
    return 0;
}

## Skip back one second.
@function int fwd() {
    if (!eventManager.waveMan)
        return -1;

    pos := eventManager.waveMan.tell();
    eventManager.waveMan.seek(pos + 44100);
    return 0;
}

@interface AppMethods {
    @abstract void setBinding(int key, Functor0[void] callback);
}

alias Callback = Functor0[void];

@function(AppMethods) int bind(int key, Callback callback) {
    self.setBinding(key, callback);
    return 0;
}

Obj makeAppWrapper(AppMethods app) {
    obj := Obj();
    obj.define('bind', bind(app));
    return obj;
}

class CrashCallback @impl Functor0[void] {
    EvalContext context;
    Block block;

    oper init(EvalContext context, Block block) :
        context = context,
        block = block {
    }

    void oper call() {
        context.pushFuncFrame();
        try {
            block.evaluate(context);
        } catch (Exception ex) {
            context.popFuncFrame();
            throw ex;
        }
    }
}

class CallbackCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Accepts only one arguments');
        return CrashCallback(context, parseBlockArg(args, 0));
    }
}

@function Obj getEventRecModule() {
    @assert(eventManager);
    return makeEventRecorderModule(eventManager);
}

class InterpWrapper {

    EvalContext __rootCtx = createRootContext();
    Poller __poller = {};

    oper init(AppMethods app) {
        __poller.add(cin, POLLIN | POLLERR);

        __rootCtx.define("stdlib", stdlib());

        __rootCtx.define('play', play());
        __rootCtx.define('get_tempo', get_tempo());
        __rootCtx.define('set_tempo', set_tempo());
        __rootCtx.define('load', load());
        __rootCtx.define('metro', metro());
        __rootCtx.define('channel_connect', channelConnect());
        __rootCtx.define('connect', connect());
        __rootCtx.define('Ev_getValue', Ev_getValue());
        __rootCtx.define('volumeControl', volumeControl());
        __rootCtx.define('setVolume', setVolume());
        __rootCtx.define('panControl', panControl());
        __rootCtx.define('setPan', setPan());
        __rootCtx.define('addEventProcessor', addEventProcessor());
        __rootCtx.define('CrashEventProcessor', CrashEventProcessorCmd());
        __rootCtx.define('seek', seek());
        __rootCtx.define('tell', tell());
        __rootCtx.define('fwd', fwd());
        __rootCtx.define('bak', bak());
        __rootCtx.define('app', makeAppWrapper(app));
        __rootCtx.define('callback', CallbackCmd());
        __rootCtx.define('evtrec', getEventRecModule());
    }

    void checkForInput() {
        if (__poller.wait(TimeDelta(0, 0))) {
            data := cin.read(1024);
            try {
                result := eval(data, __rootCtx);
                cout `$result\n`;
            } catch (Exception ex) {
                cout `got error: $ex\n`;
            }
            cout `>> `;
        }
    }

    void evalScript(String filename) {
        eval(makePath(filename).readAll(), __rootCtx);
    }
}
