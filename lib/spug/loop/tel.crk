## Crash interface for AWB.  This is named "tel" for historical reasons - it
## used to provide the interface to the "TEL" language, an early predecessor
## to Crash.

import crack.cont.array Array;
import crack.fs makePath;
import crack.functor Functor1;
import crack.lang CString, Exception;
import crack.net Poller, POLLIN, POLLERR, POLLOUT;
import crack.io cin, cout, FStr;
import crack.midi.event ControlChange, Event, NoteOn, NoteOff, Track;
import crack.time TimeDelta;
import spug.loop.model EventManager;
import spug.loop.instrument MidiInstrument;
import spug.loop.jack jackCallback, WaveManager, WindowBufferAdapter;

import crash createRootContext, eval, Builtin, EvalContext;
import types IntObj;

@import crack.ann impl;
@import ann function;

EventManager eventManager;

@function int play() {
    eventManager.togglePlay();
    return 0;
}

@function int get_tempo() {
    return eventManager.tempo;
}

@function int set_tempo(int tempo) {
    eventManager.tempo = tempo;
    return 0;
}

@function int metro(int beats) {
    metroTrack := Track('Metronome');
    metroTrack.append(NoteOn(0, 9, 31, 127));
    metroTrack.append(NoteOff(1, 9, 31, 0));

    int i;
    for (i = 1; i < beats; ++i) {
        metroTrack.append(NoteOn(i * eventManager.ppb, 9, 33, 127));
        metroTrack.append(NoteOff(i * eventManager.ppb + 1, 9, 33, 127));
    }

    eventManager.addTrack(metroTrack, i * eventManager.ppb);
    return 0;
}

@function WindowBufferAdapter load(String filename) {
    if (!eventManager.waveMan)
        eventManager.waveMan = WaveManager.create();
    return eventManager.mapWaveFile(filename);
}

@function int channelConnect(int channel, int client, int port) {
    inst := MidiInstrument(eventManager.getOutPort(client, port), byte(channel));
    eventManager.instrument[channel] = inst;
    return 0;
}

@function int connect(String source, String dest) {
    if (eventManager.waveMan)
        eventManager.waveMan.connect(CString(source), CString(dest));
    return 0;
}

alias EventProcessor = Functor1[void, Event];

class VolumeControl @impl EventProcessor {
    WindowBufferAdapter adapter;

    oper init(WindowBufferAdapter adapter) : adapter = adapter {}

    void oper call(Event event) {
        adapter.volume = ControlChange.cast(event).value / 128.0;
        cout `changing volume of $adapter to $(adapter.volume)\n`;
    }
}

@function EventProcessor volumeControl(WindowBufferAdapter adapter) {
    return VolumeControl(adapter);
}

class PanControl @impl EventProcessor {
    WindowBufferAdapter adapter;

    oper init(WindowBufferAdapter adapter) : adapter = adapter {}

    void oper call(Event event) {
        pan := ControlChange.cast(event).value / 64.0 - 1.0;
        adapter.setPan(pan);
        cout `changing panning of $adapter to $pan\n`;
    }
}

@function EventProcessor panControl(WindowBufferAdapter adapter) {
    return PanControl(adapter);
}

@function int addEventProcessor(int eventSelector, EventProcessor processor) {
    Object o = processor;
    eventManager.eventProcessors[eventSelector] = processor;
    cout `event processor's ref count is $(o.refCount)\n`;
    return 0;
}

class InterpWrapper {

    EvalContext __rootCtx = createRootContext();
    Poller __poller = {};

    oper init() {
        __poller.add(cin, POLLIN | POLLERR);

        __rootCtx.define('play', play());
        __rootCtx.define('get_tempo', get_tempo());
        __rootCtx.define('set_tempo', set_tempo());
        __rootCtx.define('load', load());
        __rootCtx.define('metro', metro());
        __rootCtx.define('channel_connect', channelConnect());
        __rootCtx.define('connect', connect());
        __rootCtx.define('volumeControl', volumeControl());
        __rootCtx.define('panControl', panControl());
        __rootCtx.define('addEventProcessor', addEventProcessor());
    }

    void checkForInput() {
        if (__poller.wait(TimeDelta(0, 0))) {
            data := cin.read(1024);
            try {
                result := eval(data, __rootCtx);
                cout `$result\n`;
            } catch (Exception ex) {
                cout `got error: $ex\n`;
            }
            cout `>> `;
        }
    }

    void evalScript(String filename) {
        eval(makePath(filename).readAll(), __rootCtx);
    }
}
