## Crash interface for AWB.  This is named "tel" for historical reasons - it
## used to provide the interface to the "TEL" language, an early predecessor
## to Crash.

import crack.cont.array Array;
import crack.lang CString, Exception;
import crack.net Poller, POLLIN, POLLERR, POLLOUT;
import crack.io cin, cout, FStr;
import crack.midi.event NoteOn, NoteOff, Track;
import crack.time TimeDelta;
import spug.loop.model EventManager;
import spug.loop.instrument MidiInstrument;
import spug.loop.jack jackCallback, WaveManager;

import crash createRootContext, eval, Builtin, EvalContext;
import types IntObj;

@import ann function;

EventManager eventManager;

@function int play() {
    eventManager.togglePlay();
    return 0;
}

@function int get_tempo() {
    return eventManager.tempo;
}

@function int set_tempo(int tempo) {
    eventManager.tempo = tempo;
    return 0;
}

@function int metro(int beats) {
    metroTrack := Track('Metronome');
    metroTrack.append(NoteOn(0, 9, 31, 127));
    metroTrack.append(NoteOff(1, 9, 31, 0));

    int i;
    for (i = 1; i < beats; ++i) {
        metroTrack.append(NoteOn(i * eventManager.ppb, 9, 33, 127));
        metroTrack.append(NoteOff(i * eventManager.ppb + 1, 9, 33, 127));
    }

    eventManager.addTrack(metroTrack, i * eventManager.ppb);
    return 0;
}

@function int loadWave(String filename) {
    if (!eventManager.waveMan) {
        eventManager.waveMan = WaveManager();
        eventManager.waveMan.init();

        # This is a hack that forces the callback and all processing
        # functions to be JITted before we activate the event loop.  If we
        # don't do this, and we're running in JIT mode, they'll get JITted
        # during the first invocation of the callback, which will exceed the
        # jack timeout and cause jack to write off this client as a zombie.
        jackCallback(0, eventManager.waveMan);

    }
    eventManager.waveMan.addFile(filename);
    return 0;
}

@function int channelConnect(int channel, int client, int port) {
    inst := MidiInstrument(eventManager.getOutPort(client, port), byte(channel));
    eventManager.instrument[channel] = inst;
    return 0;
}

@function int connect(String source, String dest) {
    if (eventManager.waveMan)
        eventManager.waveMan.connect(CString(source), CString(dest));
    return 0;
}

class InterpWrapper {

    EvalContext __rootCtx = createRootContext();
    Poller __poller = {};

    oper init() {
        __poller.add(cin, POLLIN | POLLERR);

        __rootCtx.define('play', play());
        __rootCtx.define('get_tempo', get_tempo());
        __rootCtx.define('set_tempo', set_tempo());
        __rootCtx.define('loadWave', loadWave());
        __rootCtx.define('metro', metro());
        __rootCtx.define('channel_connect', channelConnect());
        __rootCtx.define('connect', connect());
    }

    void checkForInput() {
        if (__poller.wait(TimeDelta(0, 0))) {
            data := cin.read(1024);
            try {
                result := eval(data, __rootCtx);
                cout `$result\n`;
            } catch (Exception ex) {
                cout `got error: $ex\n`;
            }
            cout `>> `;
        }
    }

}