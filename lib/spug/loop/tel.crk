## Crash interface for AWB.  This is named "tel" for historical reasons - it
## used to provide the interface to the "TEL" language, an early predecessor
## to Crash.

import crack.audio.wavfile ManagedWaveBuffer, WaveBuffer, WaveDef;
import crack.strutil split, StringArray;
import crack.cont.array Array;
import crack.fs makePath;
import crack.functor Functor0, Functor1, Functor2;
import crack.io cin, cout, cerr, FStr;
import crack.lang AppendBuffer, CString, Exception;
import crack.midi.alsa PortInfo, Sequencer, SND_SEQ_OPEN_OUTPUT,
    SND_SEQ_OPEN_INPUT;
import crack.net Poller, POLLIN, POLLERR, POLLOUT;
import crack.process Process;
import crack.runtime free;
import crack.midi.event ControlChange, Event, NoteOn, NoteOff, Track;
import crack.time TimeDelta;
import spug.loop.evtrec makeEventRecorderModule;
import spug.loop.midieng EventManagerDispatcher, MidiDispatcher, MidiEngine,
    MidiSequencer, ModelObserver;
import spug.loop.model EventContext, EventManager, Section;
import spug.loop.instrument Instrument, MidiInstrument, Orchestra;
import spug.loop.jack jackCallback, RecordBuffer, SequencerWaveModel, Wave,
    WaveAdapter, WaveManager, WaveModel, WindowBufferAdapter;

import collections collections;
import crash createRootContext, eval, parseBlockArg, ActiveFunc, Block, Builtin,
    EvalContext, Obj, ObjOf, SimpleValue, Value;
import repl repl;
import stdlib stdlib;
import types FloatObj, IntObj;
import collections wrapIterator, Iter;

import .midifile MidiFile;

@import crack.ann assert, cvars, impl, interface;
@import ann function;

EventManager eventManager;

## Toggles "play" in the event manager.
@function int play() {
    eventManager.togglePlay();
    return 0;
}

## Returns the current midi tempo.
@function int get_tempo() {
    return eventManager.tempo;
}

@function int set_tempo(int tempo) {
    eventManager.tempo = tempo;
    return 0;
}

## Returns the event manager's Orchestra object.  This is the object used to
## play most midi notes from the event manager.
@function Orchestra getOrchestra() {
    return eventManager.instrument;
}

@function int metro(int beats) {
    metroTrack := Track('Metronome');
    metroTrack.append(NoteOn(0, 9, 31, 127));
    metroTrack.append(NoteOff(1, 9, 31, 0));

    int i;
    for (i = 1; i < beats; ++i) {
        metroTrack.append(NoteOn(i * eventManager.ppb, 9, 33, 127));
        metroTrack.append(NoteOff(i * eventManager.ppb + 1, 9, 33, 127));
    }

    endTime := i * eventManager.ppb;
    eventManager.addTrack(metroTrack, endTime);

    # Add track automatically expands a new track to the size of the section
    # span, which we don't want for the metronome.
    metroTrack[-1].time = endTime;

    return 0;
}

## Loads a wave file into the next available track of the project.
@function WindowBufferAdapter load(String filename) {
    if (!eventManager.waveMan)
        eventManager.waveMan = WaveManager.create();
    return eventManager.mapWaveFile(filename);
}

## Read an entire wave file in as a Wave buffer.
@function Wave readWave(String filename) {
    return Wave.read(makePath(filename).reader());
}

## Create a SequencerWaveModel, a sequence of Wave objects (see readWave)
## positioned in time.
## These should be treated as immutable after being added to the event manager
## using addWaveModel.
@function Obj makeSequencerWaveModel() {

    ## Adds a Wave to the sequence at the specified position ('pos' is an
    ## offset in frames).
    @function(SequencerWaveModel) int add(int pos, Wave wave) {
        self.add(SequencerWaveModel.PositionedBuffer(pos, wave.channels, wave));
        return 0;
    }

    ## Append a new wave starting after the last wave.  Returns the position
    ## (frames since origin) that the wave was placed at.
    @function(SequencerWaveModel) int append(Wave wave) {
        pos := self.frames;
        self.add(SequencerWaveModel.PositionedBuffer(pos,
                                                     wave.channels,
                                                     wave
                                                     )
                 );
        return pos;
    }

    @function(SequencerWaveModel) int frames() {
        return int(self.frames);
    }

    @function(SequencerWaveModel) SequencerWaveModel getSelf() {
        return self;
    }

    @function(SequencerWaveModel) int writeToFile(String filename) {
        out := makePath(filename).writer();
        def := WaveDef(self.channels, 44100, 16);
        def.writeHeader(out);

        pos := uint(0);
        bufSize := 1024 * self.channels;
        buf := WaveBuffer(bufSize, array[int16](bufSize));
        while (pos < self.frames) {
            # Clean out the buffer.
            for (int i; i < buf.cap; ++i)
                buf[i] = 0;

            # Read either 1K frames or as many remain from the wave model.
            size := (self.frames - pos >= 1024) ? 1024 : self.frames - pos;
            self.read(pos, buf, size);

            # the read() method doesn't care about the buffer size, so we set
            # it prior to writing.
            buf.size = size * self.channels;
            def.writeData(out,  buf);

            pos += 1024;
        }
        def.finish(out);
        return 0;
    }

    swm := SequencerWaveModel();
    result := Obj();
    result.define('add', add(swm));
    result.define('append', append(swm));
    result.define('frames', frames(swm));
    result.define('self', getSelf(swm));
    result.define('writeToFile', writeToFile(swm));
    return result;
}

## Add the wave model to the engine.
@function WaveAdapter addWaveModel(WaveModel model, String trackName) {
    return eventManager.addWaveModel(model, trackName);
}

@function int addMemFile(String filename) {
    if (!eventManager.waveMan)
        return -1;

    eventManager.waveMan.addMemFile(filename);
    return 0;
}

## Load the specified AWB project file.
@function int loadProject(String filename) {
    eventManager.load(filename);
    return 0;
}

@function int channelConnect(int channel, int client, int port) {
    inst := MidiInstrument(eventManager.getOutPort(client, port), byte(channel));
    eventManager.instrument[channel] = inst;
    return 0;
}

@function(Track) String Track_getName() {
    return self.name;
}

ObjOf[Track] makeTrackObj(Track track) {
    result := ObjOf[Track](track);
    result.define('getName', Track_getName(track));
    return result;
}

## Returns an iterator over the tracks in the current section (an iterator
## over ObjOf[Track]).
##
@function Obj getTracks() {
    alias TrackArrayIter = Array[Track].ArrayIter;
    class TrackIter : Iter {
        @cvars {
            TrackArrayIter __rep;
        }
        Object elem() { return makeTrackObj(__rep.elem()) }
        bool next() { return __rep.next() }
        bool isTrue() { return __rep }
    }

    return wrapIterator(TrackIter(eventManager.curSection.tracks.iter()));
}

# Port modes.
const int PM_MIDI = 0, PM_JACK = 1;

class PortDescriptor {
    int mode;
    String name;
    oper init(String descriptor) {
        if (descriptor.startsWith('jack:')) {
            mode = PM_JACK;
            name = descriptor.substr(5);
        } else if (descriptor.startsWith('midi:')) {
            mode = PM_MIDI;
            name = descriptor.substr(5);
        } else {
            # Legacy mode.
            mode = PM_JACK;
            name = descriptor;
        }
    }

    PortInfo getPortInfo(Sequencer seq) {
        if (mode != PM_MIDI)
            throw Exception(FStr() `Port $name is not a midi port.`);

        # Get the client name/port name.
        sep := name.lfind('/');
        if (sep == -1)
            throw Exception(
                FStr() I`$(name.getRepr()) is not a legal midi port name \
                         (should be of the form <client>/<port>)`
            );
        clientName := name.substr(0, sep);
        portName := name.substr(sep + 1);

        for (client :in seq.getAllClients()) {
            if (client.getName() == clientName) {
                for (port :in client.getAllPorts(seq.seq)) {
                    if (portName == port.getName())
                        return port;
                }
            }
        }

        throw Exception(FStr() `Port $name not found.`);
    }
}

@function int connect(String source, String dest) {

    sd := PortDescriptor(source);
    dd := PortDescriptor(dest);
    if (sd.mode != dd.mode)
        throw Exception(
            FStr() `Can't connect jack ports to midi ports: $source -> $dest`
        );

    if (sd.mode == PM_JACK) {
        if (eventManager.waveMan)
            eventManager.waveMan.connect(CString(source), CString(dest));
    } else {
        sd.getPortInfo(eventManager.sequencer)
            .connect(eventManager.sequencer,
                     dd.getPortInfo(eventManager.sequencer)
                     );
    }
    return 0;
}

@function int Ev_getValue(Event event) {
    return ControlChange.cast(event).value;
}

alias EventProcessor = Functor2[void, Event, EventContext];

class VolumeControl @impl EventProcessor {
    WindowBufferAdapter adapter;

    oper init(WindowBufferAdapter adapter) : adapter = adapter {}

    void oper call(Event event, EventContext ctx) {
        adapter.mixer.volume = ControlChange.cast(event).value / 128.0;
        cout `changing volume of $adapter to $(adapter.mixer.volume)\n`;
    }
}

@function EventProcessor volumeControl(WindowBufferAdapter adapter) {
    return VolumeControl(adapter);
}

## Set the volume from a value from 0 to 127.
@function int setVolume(WindowBufferAdapter adapter, int volume) {
    adapter.mixer.volume = float(volume) / 128.0;
    cout `volume set to $(adapter.mixer.volume)\n`;
    return 0;
}

class PanControl @impl EventProcessor {
    WindowBufferAdapter adapter;

    oper init(WindowBufferAdapter adapter) : adapter = adapter {}

    void oper call(Event event, EventContext ctx) {
        pan := ControlChange.cast(event).value / 64.0 - 1.0;
        adapter.setPan(pan);
        cout `changing panning of $adapter to $pan\n`;
    }
}

@function EventProcessor panControl(WindowBufferAdapter adapter) {
    return PanControl(adapter);
}

## Set the channel pan from -32k to 32k.
@function int setPan(WindowBufferAdapter adapter, int pan) {
    # TODO: This appears to be completely wrong, setPan() accepts a float from
    # -1 to +1.
    adapter.setPan(pan);
    return 0;
}

@function int setGain(WindowBufferAdapter adapter, float gain) {
    adapter.mixer.gain = gain;
    return 0;
}

## Event processor that can run a crash script.
class CrashScriptEventProcessor @impl EventProcessor {
    EvalContext __context;
    ActiveFunc __func;

    oper init(EvalContext context, ActiveFunc func) :
        __context = context,
        __func = func {
    }

    void oper call(Event event, EventContext ctx) {
        try {
            __func.invoke(__context, Array[Object]![event]);
        } catch (Exception ex) {
            cerr `Exception caught by event dispatcher:\n$ex\n`;
        }
    }
}

## CrashEventProcessor <crash-func>
##
## Creates an event processor from a crash function.
class CrashEventProcessorCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Accepts only one argument');
        func := ActiveFunc.cast(args[0], null);
        if (!func)
            throw Exception('Argument must be a function');
        return CrashScriptEventProcessor(EvalContext(context), func);
    }
}

# Value rule constants (see ControllerOffsetChange).
const
    ## Offset is multiplied by the controller value.
    CVR_MULT := 1;

## This processor changes the controller offset, useful for midi controllers
## that send a sequence of events to do a single controller change.
##
## The parameters are the offset (a value to be added to the channel/value
## index) and the valueRule (which determines how the value of the controller
## affects the offset).
class ControllerOffsetChange @impl EventProcessor {
    @cvars {
        uint offset;
        int valueRule;
    }

    void oper call(Event event, EventContext ctx) {
        cc := ControlChange.cast(event);
        if (valueRule == CVR_MULT)
            ctx.setControllerOffset(offset * cc.value);
        else
            throw Exception(FStr() `Unknown value rule type: $(valueRule)`);
    }
}

@function ControllerOffsetChange makeControllerOffsetChange(int offset,
                                                            int valueRule
                                                            ) {
    return ControllerOffsetChange(offset, valueRule);
}

## Bind an event processor to a control number (channel << 8 + controller +
## offset).
@function int bindController(int controlNumber, EventProcessor processor) {
    eventManager.eventProcessors[controlNumber] = processor;
    return 0;
}

@function int addEventProcessor(int eventSelector, EventProcessor processor) {
    Object o = processor;
    eventManager.eventProcessors[eventSelector] = processor;
    cout `event processor's ref count is $(o.refCount)\n`;
    return 0;
}

@function int seek(int pos) {
    if (!eventManager.waveMan)
        return -1;

    eventManager.waveMan.seek(pos);
    return 0;
}

@function int tell() {
    return eventManager.waveMan.tell();
}

## Skip forward one second.
@function int bak() {
    if (!eventManager.waveMan)
        return -1;

    pos := eventManager.waveMan.tell();
    if (pos < 44100)
        return -2;

    eventManager.waveMan.seek(pos - 44100);
    return 0;
}

## Skip back one second.
@function int fwd() {
    if (!eventManager.waveMan)
        return -1;

    pos := eventManager.waveMan.tell();
    eventManager.waveMan.seek(pos + 44100);
    return 0;
}

@interface AppMethods {
    @abstract void setBinding(int key, Functor0[void] callback);
}

alias Callback = Functor0[void];

@function(AppMethods) int bind(int key, Callback callback) {
    self.setBinding(key, callback);
    return 0;
}

Obj makeAppWrapper(AppMethods app) {
    obj := Obj();
    obj.define('bind', bind(app));
    return obj;
}

class CrashCallback @impl Functor0[void] {
    EvalContext context;
    Block block;

    oper init(EvalContext context, Block block) :
        context = context,
        block = block {
    }

    void oper call() {
        context.pushFuncFrame();
        try {
            block.evaluate(context);
        } catch (Exception ex) {
            context.popFuncFrame();
            throw ex;
        }
    }
}

class CallbackCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Accepts only one arguments');
        return CrashCallback(context, parseBlockArg(args, 0));
    }
}

@function Obj getEventRecModule() {
    @assert(eventManager);
    return makeEventRecorderModule(eventManager);
}

## Command to run a command on the shell.
class ShellCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        StringArray strArgs = {};
        cerr `going through args $args\n`;
        for (arg :in args)
            strArgs.append(FStr() `$arg`);
        cerr `calling process:\n`;
        rc := Process(strArgs, 0).run();
        cerr `returning int\n`;
        return IntObj(rc);
    }
}

Obj makeTrack(Track track) {
    result := Obj();

    ## Dump the track to standard output.
    @function(Track) int dump() {
        cout `$self\n`;
        return 0;
    }

    result.define('dump', dump(track));
    return result;
}

## Returns the currently active "Section" object.
@function Obj getCurrentSection() {
    result := Obj();

    ## Returns the specified track from the current section.
    @function(Section) Obj getTrack(int index) {
        return makeTrack(self.tracks[index]);
    }

    ## Returns the number of clock ticks in a measure.
    @function(Section) int getMeasureSize() {
        return self.measure;
    }

    result.define('getTrack', getTrack(eventManager.curSection));
    result.define('getMeasureSize', getMeasureSize(eventManager.curSection));
    return result;
}

Obj _midiEngineObj;

class InstrumentDispatcher @impl Functor2[void, MidiSequencer, Event] {
    @cvars {
        Instrument instrument;
    }

    void oper call(MidiSequencer engine, Event event) {
        instrument.onEvent(event);
    }
}

class ModelObserverImpl @impl ModelObserver {
    class AddTrackCommand @impl Functor1[void, EventManager] {
        @cvars {
            Track track;
        }

        void oper call(EventManager em) {
            eventManager.addTrack(track, track[-1].time);
        }
    }

    void addTrack(Track track) {
        eventManager.commandQueue.add(AddTrackCommand(track));
    }
}

## Get the midi engine, creating it if necessary.
@function Obj getMidiEngine() {
    if (_midiEngineObj)
        return _midiEngineObj;

    if (!eventManager.waveMan)
        throw Exception('Wave manager not defined');

    seq := Sequencer(SND_SEQ_OPEN_OUTPUT | SND_SEQ_OPEN_INPUT, 0);
    seq.seq.set_client_name('AWBX'.buffer);
    eng := MidiEngine(eventManager.waveMan, seq);
    eng.setModelObserver(ModelObserverImpl());

    # XXX Hack.  Remove once we have a more principled way of adding ports.
    eng.outPort = seq.makeReadPort('out');
    seq.makeWritePort('in');

    eng.start();

    _midiEngineObj = o := Obj();

    ## Create an output port that all events are sent to.
    @function(MidiEngine) int routeToOutputPort() {
        self.addProcessor(MidiDispatcher());
        return 0;
    }

    ## Route all events to the given instrument object.
    @function(MidiEngine)
    InstrumentDispatcher routeToInstrument(Instrument instrument) {
        self.addProcessor(result := InstrumentDispatcher(instrument));
        return result;
    }

    ## Route all events to the EventManager.
    @function(MidiEngine) int routeToEventManager() {
        self.addProcessor(EventManagerDispatcher(eventManager));
        return 0;
    }

    ## Set the "input channel" parameter of the midi engine.  This value
    ## overrides the channel number for all input events.  A value of -1
    ## disables this feature and the original channel is used.
    @function(MidiEngine)
    int setInputChannel(int channel) {
        return self.inputChannel = channel;
    }

    ## Set pulses per beat (default value is 1440 [5 * 9 * 32]).  Note that
    ## this needs to be set prior to recording any tracks.
    ## This also sets the PPB in the event manager (which will likely go away
    ## soon).
    @function(MidiEngine)
    int setPPB(int val) {
        self.setPPB(val);
        eventManager.ppb = val;
        return 0;
    }

    ## Set the tempo (in beats per minute).
    @function(MidiEngine)
    int set_tempo(float bpm) {
        self.setBPM(bpm);
        return 0;
    }

    ## Toggle record mode.
    @function(MidiEngine)
    int toggleRecord() {
        self.toggleRecord();
        return 0;
    }

    ## Toggle play/idle.
    @function(MidiEngine)
    int togglePlay() {
        self.togglePlay();
        return 0;
    }

    ## Seek the specified position (in midi ticks).
    ##
    ## If the position is greater than the current end, it is wrapped around
    ## to be within range.
    @function(MidiEngine)
    int setPos(int pos) {
        self.setPos(pos);
        return 0;
    }

    ## Copy the current section in the event manager to the midi engine.
    @function(MidiEngine)
    int copySection() {
        self.setSection(eventManager.curSection.clone());
        return 0;
    }

    o.define('routeToOutputPort', routeToOutputPort(eng));
    o.define('routeToInstrument', routeToInstrument(eng));
    o.define('routeToEventManager', routeToEventManager(eng));
    o.define('setInputChannel', setInputChannel(eng));
    o.define('setPPB', setPPB(eng));
    o.define('set_tempo', set_tempo(eng));
    o.define('toggleRecord', toggleRecord(eng));
    o.define('togglePlay', togglePlay(eng));
    o.define('setPos', setPos(eng));
    o.define('copySection', copySection(eng));

    return _midiEngineObj;
}

class ExportMidiFileCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() < 2)
            throw Exception(
                'Usage: exportMidiFile <filename> <trackNum> ...'
            );
        filename := String.cast(args[0]);
        tracks := Array[Track]();
        file := MidiFile(eventManager.ppb, float(eventManager.tempo));
        for (arg :in args.subarray(1)) {
            track := eventManager.curSection.tracks[IntObj.convert(args[1]).val];
            file.append(track);
        }
        file.write(makePath(filename).writer());
        return IntObj(0);
    }
}

## Begin recording.  Returns a RecordBuffer object that you can call 'finish'
## on when done.
@function Obj recordFile(String filename) {
    if (!eventManager.waveMan)
        eventManager.waveMan = WaveManager.create();
    def := WaveDef(2, 44100, 16);
    out := makePath(filename).writer();
    def.writeHeader(out);
    buf := eventManager.waveMan.beginRecord(def, out);

    @function(RecordBuffer) int finish() {
        self.finish();
        return 0;
    }

    result := Obj();
    result.define('finish', finish(buf));
    return result;
}

## Returns a pathname form of 'path' expressed relative to 'dir'.  Both should
## be normalized absolute paths.
@function String getRelativePath(String dir, String path) {
    dirComponents := split(dir, b'/').subarray(1);
    pathComponents := split(path, b'/').subarray(1);

    # Deal with an empty root path.
    if (!dirComponents[0])
        dirComponents.delete(0);

    # Find the common root.
    int min(int a, int b) { return a < b ? a : b }
    minLen := min(pathComponents.count(), dirComponents.count());
    int common;
    for (; common < minLen; ++common) {
        if (dirComponents[common] != pathComponents[common])
            break;
    }

    # Get the relative portion of the path.
    pathComponents = pathComponents.subarray(common);

    # Insert ".." to back out any portions of the directory that are not
    # common to the path.
    for (; common < dirComponents.count(); ++common)
        pathComponents.insert(0, '..');

    buf := AppendBuffer(path.count());
    for (iter :on pathComponents) {
        if (iter.index)
            buf.append(b'/');
        buf.extend(iter.elem());
    }
    return String(buf, true);
}

class InterpWrapper {

    EvalContext __rootCtx = createRootContext();
    Poller __poller = {};

    @static void addCrashMethods(EvalContext ctx, AppMethods app) {
        ctx.define('collections', collections());
        ctx.define("stdlib", stdlib());

        ctx.define('play', play());
        ctx.define('exportMidiFile', ExportMidiFileCmd());
        ctx.define('getMidiEngine', getMidiEngine());
        ctx.define('get_tempo', get_tempo());
        ctx.define('set_tempo', set_tempo());
        ctx.define('load', load());
        ctx.define('readWave', readWave());
        ctx.define('makeSequencerWaveModel', makeSequencerWaveModel());
        ctx.define('addWaveModel', addWaveModel());
        ctx.define('addMemFile', addMemFile());
        ctx.define('getTracks', getTracks());
        ctx.define('loadProject', loadProject());
        ctx.define('getOrchestra', getOrchestra());
        ctx.define('metro', metro());
        ctx.define('channel_connect', channelConnect());
        ctx.define('connect', connect());
        ctx.define('Ev_getValue', Ev_getValue());
        ctx.define('volumeControl', volumeControl());
        ctx.define('setVolume', setVolume());
        ctx.define('panControl', panControl());
        ctx.define('setPan', setPan());
        ctx.define('setGain', setGain());
        ctx.define('makeControllerOffsetChange',
                         makeControllerOffsetChange());
        ctx.define('bindController', bindController());
        ctx.define('addEventProcessor', addEventProcessor());
        ctx.define('CrashEventProcessor', CrashEventProcessorCmd());
        ctx.define('seek', seek());
        ctx.define('shell', ShellCmd());
        ctx.define('tell', tell());
        ctx.define('fwd', fwd());
        ctx.define('bak', bak());
        ctx.define('app', makeAppWrapper(app));
        ctx.define('callback', CallbackCmd());
        ctx.define('evtrec', getEventRecModule());
        ctx.define('getCurrentSection', getCurrentSection());
        ctx.define('recordFile', recordFile());
        ctx.define('getRelativePath', getRelativePath());
        ctx.define('CVR_MULT', SimpleValue(IntObj(CVR_MULT)));
    }

    oper init(AppMethods app) {
        __poller.add(cin, POLLIN | POLLERR);

        addCrashMethods(__rootCtx, app);
    }

    void doREPL() {
        repl(__rootCtx);
    }

    void define(String name, Value value) {
        __rootCtx.define(name, value);
    }

    EvalContext getRootContext() { return __rootCtx; }

    void checkForInput() {
        if (__poller.wait(TimeDelta(0, 0))) {
            data := cin.read(1024);
            try {
                result := eval(data, __rootCtx);
                cout `$result\n`;
            } catch (Exception ex) {
                cout `got error: $ex\n`;
            }
            cout `>> `;
        }
    }

    void evalScript(String filename) {
        path := makePath(filename);
        __rootCtx.define('scriptDir',
                         SimpleValue(path.parent().getFullName())
                         );
        __rootCtx.define('scriptFile',
                         SimpleValue(path.getFullName())
                         );
        eval(path.readAll(), __rootCtx);
    }
}
