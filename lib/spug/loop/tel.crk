## Crash interface for AWB.  This is named "tel" for historical reasons - it
## used to provide the interface to the "TEL" language, an early predecessor
## to Crash.

import crack.strutil StringArray;
import crack.cont.array Array;
import crack.fs makePath;
import crack.functor Functor0, Functor1;
import crack.lang CString, Exception;
import crack.midi.alsa PortInfo, Sequencer, SND_SEQ_OPEN_OUTPUT,
    SND_SEQ_OPEN_INPUT;
import crack.net Poller, POLLIN, POLLERR, POLLOUT;
import crack.process Process;
import crack.io cin, cout, cerr, FStr;
import crack.midi.event ControlChange, Event, NoteOn, NoteOff, Track;
import crack.time TimeDelta;
import spug.loop.evtrec makeEventRecorderModule;
import spug.loop.midieng MidiDispatcher, MidiEngine;
import spug.loop.model EventManager, Section;
import spug.loop.instrument MidiInstrument;
import spug.loop.jack jackCallback, WaveManager, WindowBufferAdapter;

import crash createRootContext, eval, parseBlockArg, ActiveFunc, Block, Builtin,
    EvalContext, Obj, SimpleValue;
import stdlib stdlib;
import types FloatObj, IntObj;

import .midifile MidiFile;

@import crack.ann assert, impl, interface;
@import ann function;

EventManager eventManager;

@function int play() {
    eventManager.togglePlay();
    return 0;
}

@function int get_tempo() {
    return eventManager.tempo;
}

@function int set_tempo(int tempo) {
    eventManager.tempo = tempo;
    return 0;
}

@function int metro(int beats) {
    metroTrack := Track('Metronome');
    metroTrack.append(NoteOn(0, 9, 31, 127));
    metroTrack.append(NoteOff(1, 9, 31, 0));

    int i;
    for (i = 1; i < beats; ++i) {
        metroTrack.append(NoteOn(i * eventManager.ppb, 9, 33, 127));
        metroTrack.append(NoteOff(i * eventManager.ppb + 1, 9, 33, 127));
    }

    endTime := i * eventManager.ppb;
    eventManager.addTrack(metroTrack, endTime);

    # Add track automatically expands a new track to the size of the section
    # span, which we don't want for the metronome.
    metroTrack[-1].time = endTime;

    return 0;
}

## Loads a wave file into the next available track of the project.
@function WindowBufferAdapter load(String filename) {
    if (!eventManager.waveMan)
        eventManager.waveMan = WaveManager.create();
    return eventManager.mapWaveFile(filename);
}

## Load the specified AWB project file.
@function int loadProject(String filename) {
    eventManager.load(filename);
    return 0;
}

@function int channelConnect(int channel, int client, int port) {
    inst := MidiInstrument(eventManager.getOutPort(client, port), byte(channel));
    eventManager.instrument[channel] = inst;
    return 0;
}

# Port modes.
const int PM_MIDI = 0, PM_JACK = 1;

class PortDescriptor {
    int mode;
    String name;
    oper init(String descriptor) {
        if (descriptor.startsWith('jack:')) {
            mode = PM_JACK;
            name = descriptor.substr(5);
        } else if (descriptor.startsWith('midi:')) {
            mode = PM_MIDI;
            name = descriptor.substr(5);
        } else {
            # Legacy mode.
            mode = PM_JACK;
            name = descriptor;
        }
    }

    PortInfo getPortInfo(Sequencer seq) {
        if (mode != PM_MIDI)
            throw Exception(FStr() `Port $name is not a midi port.`);

        # Get the client name/port name.
        sep := name.lfind('/');
        if (sep == -1)
            throw Exception(
                FStr() I`$(name.getRepr()) is not a legal midi port name \
                         (should be of the form <client>/<port>)`
            );
        clientName := name.substr(0, sep);
        portName := name.substr(sep + 1);

        for (client :in seq.getAllClients()) {
            if (client.getName() == clientName) {
                for (port :in client.getAllPorts(seq.seq)) {
                    if (portName == port.getName())
                        return port;
                }
            }
        }

        throw Exception(FStr() `Port $name not found.`);
    }
}

@function int connect(String source, String dest) {

    sd := PortDescriptor(source);
    dd := PortDescriptor(dest);
    if (sd.mode != dd.mode)
        throw Exception(
            FStr() `Can't connect jack ports to midi ports: $source -> $dest`
        );

    if (sd.mode == PM_JACK) {
        if (eventManager.waveMan)
            eventManager.waveMan.connect(CString(source), CString(dest));
    } else {
        sd.getPortInfo(eventManager.sequencer)
            .connect(eventManager.sequencer,
                     dd.getPortInfo(eventManager.sequencer)
                     );
    }
    return 0;
}

@function int Ev_getValue(Event event) {
    return ControlChange.cast(event).value;
}

alias EventProcessor = Functor1[void, Event];

class VolumeControl @impl EventProcessor {
    WindowBufferAdapter adapter;

    oper init(WindowBufferAdapter adapter) : adapter = adapter {}

    void oper call(Event event) {
        adapter.mixer.volume = ControlChange.cast(event).value / 128.0;
        cout `changing volume of $adapter to $(adapter.mixer.volume)\n`;
    }
}

@function EventProcessor volumeControl(WindowBufferAdapter adapter) {
    return VolumeControl(adapter);
}

## Set the volume from a value from 0 to 127.
@function int setVolume(WindowBufferAdapter adapter, int volume) {
    adapter.mixer.volume = float(volume) / 128.0;
    cout `volume set to $(adapter.mixer.volume)\n`;
    return 0;
}

class PanControl @impl EventProcessor {
    WindowBufferAdapter adapter;

    oper init(WindowBufferAdapter adapter) : adapter = adapter {}

    void oper call(Event event) {
        pan := ControlChange.cast(event).value / 64.0 - 1.0;
        adapter.setPan(pan);
        cout `changing panning of $adapter to $pan\n`;
    }
}

@function EventProcessor panControl(WindowBufferAdapter adapter) {
    return PanControl(adapter);
}

## Set the channel pan from -32k to 32k.
@function int setPan(WindowBufferAdapter adapter, int pan) {
    # TODO: This appears to be completely wrong, setPan() accepts a float from
    # -1 to +1.
    adapter.setPan(pan);
    return 0;
}

@function int setGain(WindowBufferAdapter adapter, float gain) {
    adapter.mixer.gain = gain;
    return 0;
}

## Event processor that can run a crash script.
class CrashScriptEventProcessor @impl EventProcessor {
    EvalContext __context;
    ActiveFunc __func;

    oper init(EvalContext context, ActiveFunc func) :
        __context = context,
        __func = func {
    }

    void oper call(Event event) {
        try {
            __func.invoke(__context, Array[Object]![event]);
        } catch (Exception ex) {
            cerr `Exception caught by event dispatcher:\n$ex\n`;
        }
    }
}

## CrashEventProcessor <crash-func>
##
## Creates an event processor from a crash function.
class CrashEventProcessorCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Accepts only one argument');
        func := ActiveFunc.cast(args[0], null);
        if (!func)
            throw Exception('Argument must be a function');
        return CrashScriptEventProcessor(EvalContext(context), func);
    }
}

@function int addEventProcessor(int eventSelector, EventProcessor processor) {
    Object o = processor;
    eventManager.eventProcessors[eventSelector] = processor;
    cout `event processor's ref count is $(o.refCount)\n`;
    return 0;
}

@function int seek(int pos) {
    if (!eventManager.waveMan)
        return -1;

    eventManager.waveMan.seek(pos);
    return 0;
}

@function int tell() {
    return eventManager.waveMan.tell();
}

## Skip forward one second.
@function int bak() {
    if (!eventManager.waveMan)
        return -1;

    pos := eventManager.waveMan.tell();
    if (pos < 44100)
        return -2;

    eventManager.waveMan.seek(pos - 44100);
    return 0;
}

## Skip back one second.
@function int fwd() {
    if (!eventManager.waveMan)
        return -1;

    pos := eventManager.waveMan.tell();
    eventManager.waveMan.seek(pos + 44100);
    return 0;
}

@function int disableRead() {
    if (!eventManager.waveMan)
        return -1;

    eventManager.waveMan.disableRead();
    return 0;
}

@interface AppMethods {
    @abstract void setBinding(int key, Functor0[void] callback);
}

alias Callback = Functor0[void];

@function(AppMethods) int bind(int key, Callback callback) {
    self.setBinding(key, callback);
    return 0;
}

Obj makeAppWrapper(AppMethods app) {
    obj := Obj();
    obj.define('bind', bind(app));
    return obj;
}

class CrashCallback @impl Functor0[void] {
    EvalContext context;
    Block block;

    oper init(EvalContext context, Block block) :
        context = context,
        block = block {
    }

    void oper call() {
        context.pushFuncFrame();
        try {
            block.evaluate(context);
        } catch (Exception ex) {
            context.popFuncFrame();
            throw ex;
        }
    }
}

class CallbackCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Accepts only one arguments');
        return CrashCallback(context, parseBlockArg(args, 0));
    }
}

@function Obj getEventRecModule() {
    @assert(eventManager);
    return makeEventRecorderModule(eventManager);
}

## Command to run a command on the shell.
class ShellCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        StringArray strArgs = {};
        cerr `going through args $args\n`;
        for (arg :in args)
            strArgs.append(FStr() `$arg`);
        cerr `calling process:\n`;
        rc := Process(strArgs, 0).run();
        cerr `returning int\n`;
        return IntObj(rc);
    }
}

Obj makeTrack(Track track) {
    result := Obj();

    ## Dump the track to standard output.
    @function(Track) int dump() {
        cout `$self\n`;
        return 0;
    }

    result.define('dump', dump(track));
    return result;
}

## Returns the currently active "Section" object.
@function Obj getCurrentSection() {
    result := Obj();

    ## Returns the specified track from the current section.
    @function(Section) Obj getTrack(int index) {
        return makeTrack(self.tracks[index]);
    }

    ## Returns the number of clock ticks in a measure.
    @function(Section) int getMeasureSize() {
        return self.measure;
    }

    result.define('getTrack', getTrack(eventManager.curSection));
    result.define('getMeasureSize', getMeasureSize(eventManager.curSection));
    return result;
}

Obj _midiEngineObj;

## Get the midi engine, creating it if necessary.
@function Obj getMidiEngine() {
    if (_midiEngineObj)
        return _midiEngineObj;

    if (!eventManager.waveMan)
        throw Exception('Wave manager not defined');

    seq := Sequencer(SND_SEQ_OPEN_OUTPUT | SND_SEQ_OPEN_INPUT, 0);
    seq.seq.set_client_name('AWBX'.buffer);
    eng := MidiEngine(eventManager.waveMan, seq);

    # XXX Hack.  Remove once we have a more principled way of adding ports.
    eng.outPort = seq.makeReadPort('out');
    seq.makeWritePort('in');

    eng.start();

    _midiEngineObj = o := Obj();

    ## Create an output port that all events are sent to.
    @function(MidiEngine) int routeToOutputPort() {
        self.addProcessor(MidiDispatcher());
        return 0;
    }
    o.define('routeToOutputPort', routeToOutputPort(eng));
    return _midiEngineObj;
}

class ExportMidiFileCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() < 2)
            throw Exception(
                'Usage: exportMidiFile <filename> <trackNum> ...'
            );
        filename := String.cast(args[0]);
        tracks := Array[Track]();
        file := MidiFile(eventManager.ppb, float(eventManager.tempo));
        for (arg :in args.subarray(1)) {
            track := eventManager.curSection.tracks[IntObj.convert(args[1]).val];
            file.append(track);
        }
        file.write(makePath(filename).writer());
        return IntObj(0);
    }
}

class InterpWrapper {

    EvalContext __rootCtx = createRootContext();
    Poller __poller = {};

    oper init(AppMethods app) {
        __poller.add(cin, POLLIN | POLLERR);

        __rootCtx.define("stdlib", stdlib());

        __rootCtx.define('play', play());
        __rootCtx.define('exportMidiFile', ExportMidiFileCmd());
        __rootCtx.define('getMidiEngine', getMidiEngine());
        __rootCtx.define('get_tempo', get_tempo());
        __rootCtx.define('set_tempo', set_tempo());
        __rootCtx.define('load', load());
        __rootCtx.define('loadProject', loadProject());
        __rootCtx.define('metro', metro());
        __rootCtx.define('channel_connect', channelConnect());
        __rootCtx.define('connect', connect());
        __rootCtx.define('Ev_getValue', Ev_getValue());
        __rootCtx.define('volumeControl', volumeControl());
        __rootCtx.define('setVolume', setVolume());
        __rootCtx.define('panControl', panControl());
        __rootCtx.define('setPan', setPan());
        __rootCtx.define('setGain', setGain());
        __rootCtx.define('addEventProcessor', addEventProcessor());
        __rootCtx.define('CrashEventProcessor', CrashEventProcessorCmd());
        __rootCtx.define('seek', seek());
        __rootCtx.define('shell', ShellCmd());
        __rootCtx.define('tell', tell());
        __rootCtx.define('fwd', fwd());
        __rootCtx.define('bak', bak());
        __rootCtx.define('app', makeAppWrapper(app));
        __rootCtx.define('callback', CallbackCmd());
        __rootCtx.define('evtrec', getEventRecModule());
        __rootCtx.define('disableRead', disableRead());
        __rootCtx.define('getCurrentSection', getCurrentSection());
    }

    void checkForInput() {
        if (__poller.wait(TimeDelta(0, 0))) {
            data := cin.read(1024);
            try {
                result := eval(data, __rootCtx);
                cout `$result\n`;
            } catch (Exception ex) {
                cout `got error: $ex\n`;
            }
            cout `>> `;
        }
    }

    void evalScript(String filename) {
        path := makePath(filename);
        __rootCtx.define('scriptDir',
                         SimpleValue(path.parent().getFullName())
                         );
        __rootCtx.define('scriptFile',
                         SimpleValue(path.getFullName())
                         );
        eval(path.readAll(), __rootCtx);
    }
}

