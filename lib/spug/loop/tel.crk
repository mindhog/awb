## Crash interface for AWB.  This is named "tel" for historical reasons - it
## used to provide the interface to the "TEL" language, an early predecessor
## to Crash.

import crack.audio.wavfile ManagedWaveBuffer, WaveBuffer, WaveDef;
import crack.strutil split, StringArray;
import crack.cont.array Array;
import crack.cont.hashmap HashMap;
import crack.fs makePath;
import crack.functor Functor0, Functor1, Functor2;
import crack.io cin, cout, cerr, FStr;
import crack.lang AppendBuffer, CString, Exception;
import crack.logger levelNames, setLogLevel, DEBUG, ERROR, FATAL, INFO, WARN;
import crack.midi.alsa PortInfo, Sequencer, SND_SEQ_OPEN_OUTPUT,
    SND_SEQ_OPEN_INPUT;
import crack.net Poller, POLLIN, POLLERR, POLLOUT;
import crack.process Process;
import crack.runtime free;
import crack.midi.event ChannelEvent, ControlChange, EndTrack, Event,
    NoteEvent, NoteOn, NoteOff, Track;
import crack.midi.fluidsynth FluidSettings, FluidSynth;
import crack.time TimeDelta;
import crash.collections collections;
import crash.crash createRootContext, eval, parseBlockArg, ActiveFunc, Block, Builtin,
    EvalContext, Obj, ObjOf, ParmInfo, SimpleValue, Value;
import crash.repl repl;
import crash.stdlib stdlib;
import crash.types BoolObj, FloatObj, IntObj;
import crash.collections wrapIterator, Iter;
import spug.loop.evtrec makeEventRecorderModule;
import spug.loop.midieng ControllerDispatcher, EventProcessor,
    MidiDispatcher, MidiEngine, MidiSequencer, ModelObserver;
import spug.loop.model EventContext, MidiTrack, OmniTrack, Section;
import spug.loop.sysextra pow;
import spug.loop.jack jackCallback, RecordBuffer, SequencerWaveModel, Wave,
    WaveAdapter, WaveManager, WaveModel, WindowBufferAdapter;

import .engine engine, makeMidiEngine, AudioFileRecorder, AWBEngine,
    MidiTrackRecorder, Recorder, LEFT, RIGHT;
import .instrument FluidSynthInstrument, Instrument, MidiInstrument,
    Orchestra;
import .midifile MidiFile;
import .server startServer;

@import crack.ann assert, cvars, impl, interface;
@import crash.ann function;

@export_symbols TrackObj;

## Toggles "play" in the event manager.
@function int play() {
    engine.togglePlay();
    return 0;
}

## Returns the current midi tempo.
@function int get_tempo() {
    return engine.getTempo();
}

@function int set_tempo(int tempo) {
    engine.setTempo(tempo);
    return 0;
}

FluidSynth synth = {FluidSettings()};
synth.loadFont('/usr/share/sounds/sf2/FluidR3_GM.sf2', true);

Orchestra orch = [
    FluidSynthInstrument(synth, 0),
    FluidSynthInstrument(synth, 1),
    FluidSynthInstrument(synth, 2),
    FluidSynthInstrument(synth, 3),
    FluidSynthInstrument(synth, 4),
    FluidSynthInstrument(synth, 5),
    FluidSynthInstrument(synth, 6),
    FluidSynthInstrument(synth, 7),
    FluidSynthInstrument(synth, 8),
    FluidSynthInstrument(synth, 9),
    FluidSynthInstrument(synth, 10),
    FluidSynthInstrument(synth, 11),
    FluidSynthInstrument(synth, 12),
    FluidSynthInstrument(synth, 13),
    FluidSynthInstrument(synth, 14),
    FluidSynthInstrument(synth, 15)
];

alias InstrumentObj = ObjOf[Instrument];

InstrumentObj makeInstrumentObj(Instrument inst) {
    @function(Instrument) int setProgram(int programNumber) {
        self.programChange(byte(programNumber));
        return programNumber;
    }

    result := InstrumentObj(inst);
    result.define('setProgram', setProgram(inst));
    return result;
}

alias OrchestraObj = ObjOf[Orchestra];

## Returns the Orchestra object, which can be used as a routing destination
## for the midi engine.
@function OrchestraObj getOrchestra() {
    @function(Orchestra) InstrumentObj getInstrument(int index) {
        return makeInstrumentObj(orch.getChild(byte(index)));
    }

    result := OrchestraObj(orch);
    result.define('getInstrument', getInstrument(orch));
    return result;
}

@function int metro(int beats) {
    metroTrack := Track('Metronome');
    metroTrack.append(NoteOn(0, 9, 31, 127));
    metroTrack.append(NoteOff(1, 9, 31, 0));

    int i;
    ppb := engine.getPPB();
    for (i = 1; i < beats; ++i) {
        metroTrack.append(NoteOn(i * ppb, 9, 33, 127));
        metroTrack.append(NoteOff(i * ppb + 1, 9, 33, 127));
    }

    metroTrack.append(EndTrack(i * ppb));
    engine.addTrack(metroTrack);

    return 0;
}

## Loads a wave file into the next available track of the project.
@function WindowBufferAdapter load(String filename) {
    return engine.addWaveFile(filename);
}

## Read an entire wave file in as a Wave buffer.
@function Wave readWave(String filename) {
    return Wave.read(makePath(filename).reader());
}

## Lengthen a wave by repeating the last nframes frames reps times.  rampLen
## is the length of the cross-fade.
##
## Lengthening is done by cross-fading the last nframes over the last rampLen
## of the wave, then extending with the remainder of the span, cross-faded to
## smoothly merge into its own ending until the wave is extended by reps
## instances of the nframes long repeat buffer (the wave is thus ultimately
## extended by reps * nframes - reps * rampLen frames).
@function int lengthenWave(Wave wave, int nframes, int reps, int rampLen) {
    reps := 5;
    # Sample the last second.
    nframes := 44100 * 2;
    buf := ManagedWaveBuffer(nframes * wave.channels);
    for (int i = wave.size - nframes * wave.channels; i < wave.size; ++i)
        buf.append(wave[i]);

    # Cross-fade ramp up/down time in samples.
    rampLen := 16000;

    # Mix in at the end of the wave.
    for (int i; i < rampLen; ++i) {
        for (int ch; ch < wave.channels; ++ch) {
            pos := wave.size - (rampLen - i) * wave.channels + ch;
            wave[pos] =
                int16(wave[pos] * float(rampLen - i) / float(rampLen)) +
                int16(buf[i * wave.channels + ch] * float(i) / float(rampLen));
        }
    }

    wave.grow(wave.size + reps * nframes * wave.channels);

    # Add multiple repetitions of the buffer.
    for (int i; i < reps; ++i) {

        # do the middle of the buffer (no mix-in)
        pos := rampLen * wave.channels;
        for (; pos < buf.size - rampLen * wave.channels; ++pos)
            wave.append(buf[pos]);

        # mix the end of the buffer with its beginning.
        for (int j; j < rampLen; ++j) {
            for (int ch; ch < wave.channels; ++ch) {
                wave.append(
                    int16(
                        buf[buf.size - (rampLen - j) * wave.channels + ch] *
                            float(rampLen - j) / float(rampLen) +
                        buf[j * wave.channels + ch] * float(j) / float(rampLen)
                    )
                );
            }
        }
    }

    return 0;
}

## Write the wave to the specified file.
@function int writeWave(String fileName, Wave wave) {
    def := WaveDef(wave.channels, wave.rate, 16);
    out := makePath(fileName).writer();
    def.writeHeader(out);

    class Buf : WaveBuffer {
        oper init() : WaveBuffer(0, null) {}

        Buf from(uintz size, array[int16] buffer) {
            this.size = cap = size;
            this.buffer = buffer;
            return this;
        }
    }
    buf := Buf();

    pos := 0;
    for (; pos < wave.size / 4096 * 4096; pos += 4096)
        def.writeData(out, buf.from(4096, wave.buffer + pos));

    if (pos != wave.size)
        def.writeData(out, buf.from(wave.size - pos, wave.buffer + pos));
    def.finish(out);
    return 0;
}

alias SequencerWaveModelObj = ObjOf[SequencerWaveModel];

## Create a SequencerWaveModel, a sequence of Wave objects (see readWave)
## positioned in time.
## These should be treated as immutable after being added to the event manager
## using addWaveModel.
@function SequencerWaveModelObj makeSequencerWaveModel() {

    ## Adds a Wave to the sequence at the specified position ('pos' is an
    ## offset in frames).
    @function(SequencerWaveModel) int add(int pos, Wave wave) {
        self.add(SequencerWaveModel.PositionedBuffer(pos, wave.channels, wave,
                                                     wave.rate
                                                     )
                 );
        return 0;
    }

    ## Append a new wave starting after the last wave.  Returns the position
    ## (frames since origin) that the wave was placed at.
    @function(SequencerWaveModel) int append(Wave wave) {
        pos := self.frames;
        self.add(SequencerWaveModel.PositionedBuffer(pos,
                                                     wave.channels,
                                                     wave,
                                                     wave.rate
                                                     )
                 );
        return pos;
    }

    @function(SequencerWaveModel) int frames() {
        return int(self.frames);
    }

    @function(SequencerWaveModel) SequencerWaveModel getSelf() {
        return self;
    }

    @function(SequencerWaveModel) int writeToFile(String filename) {
        out := makePath(filename).writer();
        def := WaveDef(self.channels, 44100, 16);
        def.writeHeader(out);

        pos := uint(0);
        bufSize := 1024 * self.channels;
        buf := WaveBuffer(bufSize, array[int16](bufSize));
        while (pos < self.frames) {
            # Clean out the buffer.
            for (int i; i < buf.cap; ++i)
                buf[i] = 0;

            # Read either 1K frames or as many remain from the wave model.
            size := (self.frames - pos >= 1024) ? 1024 : self.frames - pos;
            self.read(pos, buf, size);

            # the read() method doesn't care about the buffer size, so we set
            # it prior to writing.
            buf.size = size * self.channels;
            def.writeData(out,  buf);

            pos += 1024;
        }
        def.finish(out);
        return 0;
    }

    swm := SequencerWaveModel();
    result := SequencerWaveModelObj(swm);
    result.define('add', add(swm));
    result.define('append', append(swm));
    result.define('frames', frames(swm));
    result.define('self', getSelf(swm));
    result.define('writeToFile', writeToFile(swm));
    return result;
}

## Add the wave model to the engine.
@function WaveAdapter addWaveModel(WaveModel model, String trackName) {
    return engine.addWaveModel(model, trackName);
}

@function int addMemFile(String filename) {
    engine.getWaveManager().addMemFile(filename);
    return 0;
}

## Load the specified AWB project file.
@function int loadProject(String filename) {
    engine.loadProject(filename);
    return 0;
}

## Save an AWB project file.
@function int saveProject() {
    engine.saveClassicProjectFile();
    return 0;
}

## Connect the internal orchestra channel to the given midi client and port.
@function int channelConnect(int channel, int client, int port) {
    inst := MidiInstrument(engine.getOutPort(client, port),
                           byte(channel));
    orch[channel] = inst;
    return 0;
}

alias TrackObj = ObjOf[Track];

TrackObj makeTrackObj(Track track) {
    result := TrackObj(track);

    @function(Track) String getName() {
        return self.name;
    }

    ## Returns true if the track is a midi track.
    @function(Track) bool isMidi() {
        # This is kind of weak, we need to convert all tracks to OmniTrack.
        # But for now, we can recognize a midi track as a track having more
        # than one event (the TrackEnd event is present for both midi and
        # audio tracks).
        return self.count() > 1;
    }

    ## Dump the track to standard output.
    @function(Track) int dump() {
        cout `$self\n`;
        return 0;
    }

    @function(Track) TrackObj crunch(int ticks) {
        return makeTrackObj(MidiTrack.crunch(self, ticks));
    }

    @function(Track) TrackObj clone() {
        return makeTrackObj(MidiTrack.clone(self));
    }

    result.define('getName', getName(track));
    result.define('isMidi', isMidi(track));
    result.define('dump', dump(track));
    result.define('crunch', crunch(track));
    result.define('clone', clone(track));
    return result;
}

## Returns an iterator over the tracks in the current section (an iterator
## over ObjOf[Track]).
##
## In addition to the normal iterator methods, the result includes a "last"
## method which returns the last track (or null for an empty track list).
@function Obj getTracks() {
    alias TrackArrayIter = Array[Track].ArrayIter;
    class TrackIter : Iter {
        @cvars {
            TrackArrayIter __rep;
        }
        Object elem() { return makeTrackObj(__rep.elem()) }
        bool next() { return __rep.next() }
        bool isTrue() { return __rep }
    }

    ## Returns the last track of the iterator (effectively invalidating the
    ## iterator in the process).
    @function(TrackIter) Object last() {
        Object result;
        while (self) {
            result = self.elem();
            self.next();
        }
        return result;
    }

    iter := TrackIter(engine.getAllTracks().iter());
    result := wrapIterator(iter);
    result.define('last', last(iter));
    return result;
}

# Port modes.
const int PM_MIDI = 0, PM_JACK = 1;

class PortDescriptor {
    int mode;
    String name;
    oper init(String descriptor) {
        if (descriptor.startsWith('jack:')) {
            mode = PM_JACK;
            name = descriptor.substr(5);
        } else if (descriptor.startsWith('midi:')) {
            mode = PM_MIDI;
            name = descriptor.substr(5);
        } else {
            # Legacy mode.
            mode = PM_JACK;
            name = descriptor;
        }
    }

    PortInfo getPortInfo(Sequencer seq) {
        if (mode != PM_MIDI)
            throw Exception(FStr() `Port $name is not a midi port.`);

        # Get the client name/port name.
        sep := name.lfind('/');
        if (sep == -1)
            throw Exception(
                FStr() I`$(name.getRepr()) is not a legal midi port name \
                         (should be of the form <client>/<port>)`
            );
        clientName := name.substr(0, sep);
        portName := name.substr(sep + 1);

        for (client :in seq.getAllClients()) {
            if (client.getName() == clientName) {
                for (port :in client.getAllPorts(seq.seq)) {
                    if (portName == port.getName())
                        return port;
                }
            }
        }

        throw Exception(FStr() `Port $name not found.`);
    }
}

@function int connect(String source, String dest) {

    sd := PortDescriptor(source);
    dd := PortDescriptor(dest);
    if (sd.mode != dd.mode)
        throw Exception(
            FStr() `Can't connect jack ports to midi ports: $source -> $dest`
        );

    if (sd.mode == PM_JACK) {
        engine.getWaveManager().connect(CString(source), CString(dest));
    } else {
        seq := engine.getSequencer();
        sd.getPortInfo(seq).connect(seq, dd.getPortInfo(seq));
    }
    return 0;
}

@function int disconnect(String source, String dest) {
    sd := PortDescriptor(source);
    dd := PortDescriptor(dest);
    if (sd.mode != PM_JACK)
        throw Exception(
            FStr() `Source port $source in disconnect() is not a jack port.`
        );
    if (dd.mode != PM_JACK)
        throw Exception(
            FStr() `Destination port $dest in disconnect() is not a jack port.`
        );
    engine.getWaveManager().disconnect(CString(source), CString(dest));
    return 0;
}

@function int Ev_getValue(Event event) {
    return ControlChange.cast(event).value;
}

# Note that this is the _old style_ EventProcessor, prefer the
# midieng.EventProcessor instead.
alias LegacyEventProcessor = Functor2[void, Event, EventContext];

class VolumeControl @impl LegacyEventProcessor {
    WindowBufferAdapter adapter;

    oper init(WindowBufferAdapter adapter) : adapter = adapter {}

    void oper call(Event event, EventContext ctx) {
        adapter.mixer.volume = ControlChange.cast(event).value / 128.0;
        cout `changing volume of $adapter to $(adapter.mixer.volume)\n`;
    }
}

@function LegacyEventProcessor volumeControl(WindowBufferAdapter adapter) {
    return VolumeControl(adapter);
}

## Set the volume from a value from 0 to 127.
@function int setVolume(WindowBufferAdapter adapter, int volume) {
    adapter.mixer.volume = float(volume) / 128.0;
    cout `volume set to $(adapter.mixer.volume)\n`;
    return 0;
}

class PanControl @impl LegacyEventProcessor {
    WindowBufferAdapter adapter;

    oper init(WindowBufferAdapter adapter) : adapter = adapter {}

    void oper call(Event event, EventContext ctx) {
        pan := ControlChange.cast(event).value / 64.0 - 1.0;
        adapter.setPan(pan);
        cout `changing panning of $adapter to $pan\n`;
    }
}

@function LegacyEventProcessor panControl(WindowBufferAdapter adapter) {
    return PanControl(adapter);
}

## Set the channel pan from -32k to 32k.
@function int setPan(WindowBufferAdapter adapter, int pan) {
    # TODO: This appears to be completely wrong, setPan() accepts a float from
    # -1 to +1.
    adapter.setPan(pan);
    return 0;
}

@function int setGain(WindowBufferAdapter adapter, float gain) {
    adapter.mixer.gain = gain;
    return 0;
}

## Event processor that can run a crash script.
class CrashScriptEventProcessor @impl LegacyEventProcessor {
    EvalContext __context;
    ActiveFunc __func;

    oper init(EvalContext context, ActiveFunc func) :
        __context = context,
        __func = func {
    }

    void oper call(Event event, EventContext ctx) {
        try {
            __func.invoke(__context, Array[Object]![event]);
        } catch (Exception ex) {
            cerr `Exception caught by event dispatcher:\n$ex\n`;
        }
    }
}

## CrashEventProcessor <crash-func>
##
## Creates a legacy event processor from a crash function.
class CrashEventProcessorCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Accepts only one argument');
        func := ActiveFunc.cast(args[0], null);
        if (!func)
            throw Exception('Argument must be a function');
        return CrashScriptEventProcessor(EvalContext(context), func);
    }
}

# Value rule constants (see ControllerOffsetChange).
const
    ## Offset is multiplied by the controller value.
    CVR_MULT := 1;

## This processor changes the controller offset, useful for midi controllers
## that send a sequence of events to do a single controller change.
##
## The parameters are the offset (a value to be added to the channel/value
## index) and the valueRule (which determines how the value of the controller
## affects the offset).
class ControllerOffsetChange @impl LegacyEventProcessor {
    @cvars {
        uint offset;
        int valueRule;
    }

    void oper call(Event event, EventContext ctx) {
        cc := ControlChange.cast(event);
        if (valueRule == CVR_MULT)
            ctx.setControllerOffset(offset * cc.value);
        else
            throw Exception(FStr() `Unknown value rule type: $(valueRule)`);
    }
}

@function ControllerOffsetChange makeControllerOffsetChange(int offset,
                                                            int valueRule
                                                            ) {
    return ControllerOffsetChange(offset, valueRule);
}

## Bind an event processor to a control number (channel << 8 + controller +
## offset).
@function int bindController(int controlNumber,
                             LegacyEventProcessor processor
                             ) {
    engine.addEventProcessor(controlNumber, processor);
    return 0;
}

@function int addEventProcessor(int eventSelector,
                                LegacyEventProcessor processor
                                ) {
    engine.addEventProcessor(eventSelector, processor);
    return 0;
}

alias ControllerDispatcherObj = ObjOf[ControllerDispatcher];
@function ControllerDispatcherObj makeControllerDispatcher() {
    dispatcher := ControllerDispatcher();
    result := ControllerDispatcherObj(dispatcher);

    ## Set the controller offset, a value added to the controller number for
    ## all events.
    @function(ControllerDispatcher) int setControllerOffset(int offset) {
        self.setControllerOffset(offset);
        return 0;
    }

    ## Set the legacy event processor to be used for a specific controller id
    ## (after adding the offset).
    @function(ControllerDispatcher) int setEventProcessor(
        int eventSelector,
        LegacyEventProcessor processor
    ) {
        self.setEventProcessor(eventSelector, processor);
        return 0;
    }

    result.define('setControllerOffset', setControllerOffset(dispatcher));
    result.define('setEventProcessor', setEventProcessor(dispatcher));
    return result;
}

@function int seek(int pos) {
    engine.getWaveManager().seek(pos);
    return 0;
}

@function int tell() {
    return engine.getWaveManager().tell();
}

## Skip forward one second.
@function int bak() {
    waveMan := engine.getWaveManager();
    pos := waveMan.tell();
    if (pos < 44100)
        return -2;

    waveMan.seek(pos - 44100);
    return 0;
}

## Skip back one second.
@function int fwd() {
    waveMan := engine.getWaveManager();
    pos := waveMan.tell();
    waveMan.seek(pos + 44100);
    return 0;
}

@interface AppMethods {
    @abstract void setBinding(int key, Functor0[void] callback);
}

alias Callback = Functor0[void];

@function(AppMethods) int bind(int key, Callback callback) {
    self.setBinding(key, callback);
    return 0;
}

Obj makeAppWrapper(AppMethods app) {
    obj := Obj();
    obj.define('bind', bind(app));
    return obj;
}

class CrashCallback @impl Functor0[void] {
    EvalContext context;
    Block block;

    oper init(EvalContext context, Block block) :
        # Make a copy of the current context in order to
        # a) retain the stack we had when the binding was made and
        # b) not mess up the current context when we pop
        context(context),
        block = block {
    }

    void oper call() {
        context.pushFuncFrame();
        try {
            block.evaluate(context);
        } catch (Exception ex) {
            context.popFuncFrame();
            throw ex;
        }
    }
}

class CallbackCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Accepts only one arguments');
        return CrashCallback(context, parseBlockArg(args, 0));
    }
}

@function Obj getEventRecModule() {
    return makeEventRecorderModule(engine);
}

## Command to run a command on the shell.
class ShellCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        StringArray strArgs = {};
        cerr `going through args $args\n`;
        for (arg :in args)
            strArgs.append(FStr() `$arg`);
        cerr `calling process:\n`;
        rc := Process(strArgs, 0).run();
        cerr `returning int\n`;
        return IntObj(rc);
    }
}

alias SectionObj = ObjOf[Section];

SectionObj makeSectionObj(Section section);

## Returns the currently active "Section" object.
@function SectionObj getCurrentSection() {
    section := engine.getCurrentSection();
    return makeSectionObj(section);
}

Obj _engineObj;

class InstrumentDispatcher @impl Functor2[bool, MidiSequencer, Event] {
    @cvars {
        Instrument instrument;
    }

    bool oper call(MidiSequencer engine, Event event) {
        instrument.onEvent(event);
        return true;
    }
}

class ExportMidiFileCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() < 2)
            throw Exception(
                'Usage: exportMidiFile <filename> <trackNum> ...'
            );
        filename := String.cast(args[0]);
        trackNums := Array[int]();
        for (arg :in args.subarray(1))
            trackNums.append(IntObj.convert(args[1]).val);
        engine.exportMidiFile(filename, trackNums);
        return IntObj(0);
    }
}

## Begin recording to a stereo file.  Returns a RecordBuffer object that you
## can call 'finish' on when done.
@function Obj recordFile(String filename) {
    RecordBuffer buf;
    buf = engine.recordStereoFile(filename);

    @function(RecordBuffer) int finish() {
        self.finish();
        return 0;
    }

    ## Enable/disable monitoring.  If monitoring is enabled, the record signal
    ## is copied to the output mix.
    @function(RecordBuffer) bool enableMonitor(bool monitor) {
        self.monitor = monitor;
        return monitor;
    }

    ## Returns true if the recorder is monitoring.
    @function(RecordBuffer) bool monitor() {
        return self.monitor;
    }

    ## Returns the start position of the recording.
    @function(RecordBuffer) int startPos() {
        return self.startPos;
    }

    result := Obj();
    result.define('finish', finish(buf));
    result.define('enableMonitor', enableMonitor(buf));
    result.define('monitor', monitor(buf));
    result.define('startPos', startPos(buf));

    return result;
}

## Returns a pathname form of 'path' expressed relative to 'dir'.  Both should
## be normalized absolute paths.
@function String getRelativePath(String dir, String path) {
    dirComponents := split(dir, b'/').subarray(1);
    pathComponents := split(path, b'/').subarray(1);

    # Deal with an empty root path.
    if (!dirComponents[0])
        dirComponents.delete(0);

    # Find the common root.
    int min(int a, int b) { return a < b ? a : b }
    minLen := min(pathComponents.count(), dirComponents.count());
    int common;
    for (; common < minLen; ++common) {
        if (dirComponents[common] != pathComponents[common])
            break;
    }

    # Get the relative portion of the path.
    pathComponents = pathComponents.subarray(common);

    # Insert ".." to back out any portions of the directory that are not
    # common to the path.
    for (; common < dirComponents.count(); ++common)
        pathComponents.insert(0, '..');

    buf := AppendBuffer(path.count());
    for (iter :on pathComponents) {
        if (iter.index)
            buf.append(b'/');
        buf.extend(iter.elem());
    }
    return String(buf, true);
}

## Set the "log level" (the minimum priority level that is displayed to the
## console).
##
## Levels are DEBUG, INFO, WARN, ERROR and FATAL.
@function int setLogLevel_(String level) {
    for (i :on levelNames) {
        if (i.elem() == level) {
            setLogLevel(i.index);
            return i.index;
        }
    }
    throw Exception(FStr() `Unknown log level: $level`);
}

## Write 'text' to standard error.
@function int prerr(String text) {
    cerr `$text`;
    return 0;
}

## Returns the class name of 'obj'.  Useful for debugging.
@function String className(Object obj) {
    return FStr() `$(obj.class.name)`;
}

alias AudioFileRecorderObj = ObjOf[AudioFileRecorder];

@function
AudioFileRecorderObj makeAudioFileRecorder(String filename, int channels) {
    inst := AudioFileRecorder(filename, channels);
    result := AudioFileRecorderObj(inst);

    @function(AudioFileRecorder) bool enableMonitor(bool enabled) {
        return self.monitor = enabled;
    }

    @function(AudioFileRecorder) bool monitor() {
        return self.monitor;
    }

    alias VoidFunctor = Functor0[void];
    @function(AudioFileRecorder) int setCloseCallback(VoidFunctor cb) {
        self.closeCallback = cb;
        return 0;
    }

    @function(AudioFileRecorder) int startPos() {
        return self.buf.startPos;
    }

    @function(AudioFileRecorder) int setFilename(String filename) {
        self.filename = filename;
        return 0;
    }

    result.define('enableMonitor', enableMonitor(inst));
    result.define('monitor', monitor(inst));
    result.define('setCloseCallback', setCloseCallback(inst));
    result.define('startPos', startPos(inst));
    result.define('setFilename', setFilename(inst));
    return result;
}

@function MidiTrackRecorder makeMidiTrackRecorder() {
    return MidiTrackRecorder();
}

alias OmniTrackObj = ObjOf[OmniTrack];

OmniTrackObj makeOmniTrackObj(OmniTrack track) {
    @function(OmniTrack) OmniTrackObj rename(String name) {
        return makeOmniTrackObj(self.rename(name));
    }

    result := OmniTrackObj(track);
    result.define('rename', rename(track));
    return result;
}

SectionObj makeSectionObj(Section section) {
    @function(Section) OmniTrackObj getTrack(int index) {
        return makeOmniTrackObj(self.getTrack(uint(index)));
    }

    ## Returns the number of clock ticks in a measure.
    @function(Section) int getMeasureSize() {
        return self.measure;
    }

    result := SectionObj(section);
    result.define('getTrack', getTrack(section));
    result.define('getMeasureSize', getMeasureSize(section));
    return result;
}

## An input processor that maps one note to another in NoteOn/NoteOff events.
class NoteMapper @impl EventProcessor {
    HashMap[int, int] __map = {};

    void map(int orgNote, int newNote) {
        __map[orgNote] = newNote;
    }

    bool oper call(MidiSequencer seq, Event event) {
        if (e := NoteEvent.cast(event, null)) {
            e.note = byte(__map.get(e.note, e.note));
        }
        return false;
    }
}

alias NoteMapperObj = ObjOf[NoteMapper];

## Returns a NoteMapper object, which is an event processor that maps one note
## to another.
##
## NoteMapper has a "map" method that accepts to integers and causes the
## mapper to do the translation for a specific note.
@function NoteMapperObj makeNoteMapper() {

    @function(NoteMapper) int map(int orgNote, int newNote) {
        self.map(orgNote, newNote);
        return 0;
    }

    self := NoteMapper();
    result := NoteMapperObj(self);
    result.define('map', map(self));
    return result;
}

## An input processor that converts the channel of all channel events to the
## specified value.
class ChannelMapper @impl EventProcessor {
    @cvars {
        ## The new channel number for all output events.
        int newChannel;
    }

    bool oper call(MidiSequencer seq, Event event) {
        if (e := ChannelEvent.cast(event, null))
            e.channel = byte(newChannel);
        return false;
    }
}

alias ChannelMapperObj = ObjOf[ChannelMapper];

## Returns a new channel mapper object, which changes the channel of all
## ChannelEvent's to the value specified in the argument.
@function ChannelMapperObj makeChannelMapper(int newChannel) {

    ## Set the new channel that all events get mapped to.
    @function(ChannelMapper) int setNewChannel(int channel) {
        self.newChannel = channel;
        return channel;
    }

    ## Returns the new channel that all events get ampped to.
    @function(ChannelMapper) int getNewChannel() {
        return self.newChannel;
    }

    mapper := ChannelMapper(newChannel);
    result := ChannelMapperObj(mapper);
    result.define('setNewChannel', setNewChannel(mapper));
    result.define('getNewChannel', getNewChannel(mapper));
    return result;
}

## An input processor that delegates to another input processor for a channel
## event on a specific channel.
class ChannelPredicate @impl EventProcessor {
    @cvars {
        ## The channel to invoke the delgated processor for.
        int channel;

        ## The processor to be delgated to.
        EventProcessor processor;
    }

    bool oper call(MidiSequencer seq, Event event) {
        if ((e := ChannelEvent.cast(event, null)) && e.channel == channel)
            return processor(seq, event);
        else
            return false;
    }
}

alias ChannelPredicateObj = ObjOf[ChannelPredicate];

## Returns a new channel predicate object.
##
## Channel predicates delgate to another input processor for events on a
## specific channel.
##
## ChannelPredicate <channel> <delegate-processor>
@function ChannelPredicateObj makeChannelPredicate(int channel,
                                                   EventProcessor delegate
                                                   ) {
    return ChannelPredicateObj(ChannelPredicate(channel, delegate));
}

## Get the new engine facade.
@function Obj get_engine() {
    if (_engineObj)
        return _engineObj;

    _engineObj = result := ObjOf[AWBEngine](engine);

    @function(AWBEngine) int play() {
        self.play();
        return 0;
    }

    @function(AWBEngine) int pause() {
        self.pause();
        return 0;
    }

    @function(AWBEngine) int addRecorder(Recorder rec) {
        self.addRecorder(rec);
        return 0;
    }

    @function(AWBEngine) int removeRecorder(Recorder rec) {
        self.removeRecorder(rec);
        return 0;
    }

    @function(AWBEngine) int clearRecorders() {
        self.clearRecorders();
        return 0;
    }

    @function(AWBEngine) int record() {
        self.record();
        return 0;
    }

    ## Toggle record mode.
    @function(AWBEngine) int toggleRecord() {
        self.toggleRecord();
        return 0;
    }

    @function(AWBEngine) int togglePlay() {
        self.togglePlay();
        return 0;
    }

    ## Set pulses per beat (default value is 1440 [5 * 9 * 32]).  Note that
    ## this needs to be set prior to recording any tracks.
    ## This also sets the PPB in the event manager (which will likely go away
    ## soon).
    @function(AWBEngine)
    int setPPB(int val) {
        self.setPPB(val);
        return 0;
    }

    ## Returns the current section.
    @function(AWBEngine) SectionObj getCurrentSection() {
        return makeSectionObj(self.getCurrentSection());
    }

    ## Copy the current section in the event manager to the midi engine.
    @function(AWBEngine) int copySection() {
        self.copySection();
        return 0;
    }

    @function(AWBEngine) int addTrack(Track track) {
        self.addTrack(track);
        return 0;
    }

    ## Delete the track in the current section at the specified index.
    @function(AWBEngine) int deleteTrack(int index) {
        self.deleteTrack(index);
        return 0;
    }

    ## Replace the specified track in the current section with the new track.
    ##
    ## This method can accept any of Track, OmniTrack or their corresponding
    ## crash wrappers (TrackObj, OmniTrackObj).
    @function(AWBEngine) int replaceTrack(int index, Object track) {
        OmniTrack omniTrack;
        if (t := TrackObj.cast(track, null))
            omniTrack = MidiTrack(Track.cast(t.convertTo(Track)));
        else if (t := OmniTrackObj.cast(track, null))
            omniTrack = OmniTrack.cast(t.convertTo(OmniTrack));
        else if (t := OmniTrack.cast(track, null))
            omniTrack = t;
        else if (t := Track.cast(track, null))
            omniTrack = MidiTrack(t);
        else
            throw Exception(
                FStr() `Can't convert $track to OmniTrack or Track`
            );
        self.replaceTrack(index, omniTrack);
        return 0;
    }

    ## Load the midi file and add all tracks to the engine.
    @function(AWBEngine)
    int loadMidiFile(String filename) {
        self.addMidiFile(filename);
        return 0;
    }

    ## Sets the global tempo (in beats per minute).  Different portions of
    ## the piece can have different tempos, but they're all scaled to the
    ## global tempo.
    @function(AWBEngine) int setTempo(int bpm) {
        self.setTempo(bpm);
        return 0;
    }

    ## Reset the play position to the start of the current section.
    @function(AWBEngine) int resetPos() {
        self.resetPos();
        return 0;
    }

    ## Seek the specified position (in midi ticks).
    ##
    ## If the position is greater than the current end, it is wrapped around
    ## to be within range.
    @function(AWBEngine) int setPos(int pos) {
        self.setPos(pos);
        return 0;
    }

    ## Add an input processor to the midi input event chain.
    @function(AWBEngine) int addInputProcessor(EventProcessor processor) {
        self.addInputProcessor(processor);
        return 0;
    }

    ## Insert an event processor at the given index in the input processor
    ## chain.
    @function(AWBEngine) int insertInputProcessor(int index,
                                                  EventProcessor processor) {
        self.insertInputProcessor(index, processor);
        return 0;
    }

    ## Remove the specified event processor from the input processor chain.
    @function(AWBEngine) int removeInputProcessor(EventProcessor processor) {
        self.removeInputProcessor(processor);
        return 0;
    }

    ## Set the "input channel" parameter of the midi engine.  This value
    ## overrides the channel number for all input events.  A value of -1
    ## disables this feature and the original channel is used.
    ##
    ## In general, you're usually better off adding a ChannelMapper to either
    ## the input or output chain.
    @function(AWBEngine)
    int setInputChannel(int channel) {
        return self.getMidiEngine().inputChannel = channel;
    }

    ## Add an output processor to the midi input event chain.
    @function(AWBEngine) int addOutputProcessor(EventProcessor processor) {
        self.addOutputProcessor(processor);
        return 0;
    }

    ## Insert an event processor at the given index in the output processor
    ## chain.
    @function(AWBEngine) int insertOutputProcessor(int index,
                                                   EventProcessor processor) {
        self.insertOutputProcessor(index, processor);
        return 0;
    }

    ## Remove the specified event processor from the output processor chain.
    @function(AWBEngine) int removeOutputProcessor(EventProcessor processor) {
        self.removeOutputProcessor(processor);
        return 0;
    }

    ## Adds a midi output processor that sends all events to the midi output
    ## port.
    @function(AWBEngine) int routeToOutputPort() {
        self.addOutputProcessor(MidiDispatcher());
        return 0;
    }

    ## Route all events to the given instrument object.  Adds an output
    ## processor that sends events to an InstrumentDispatcher created for the
    ## Instrument, returning the new InstrumentDispatcher.
    @function(AWBEngine)
    InstrumentDispatcher routeToInstrument(Instrument instrument) {
        self.addOutputProcessor(result := InstrumentDispatcher(instrument));
        return result;
    }

    @function(AWBEngine) int setMidiRecordTrackName(String name) {
        self.setMidiRecordTrackName(name);
        return 0;
    }

    ## Create a new, empty section.
    ##
    ## Returns the new section index.
    @function(AWBEngine) int createNewSection() {
        return self.createSection(null);
    }

    ## Set the current section to the section indexed by 'index'.
    @function(AWBEngine) int setSection(int index) {
        self.setSection(index);
        return 0;
    }

    result.define('play', play(engine));
    result.define('pause', pause(engine));
    result.define('addRecorder', addRecorder(engine));
    result.define('removeRecorder', removeRecorder(engine));
    result.define('clearRecorders', clearRecorders(engine));
    result.define('record', record(engine));
    result.define('toggleRecord', toggleRecord(engine));
    result.define('togglePlay', togglePlay(engine));
    result.define('setPPB', setPPB(engine));
    result.define('addTrack', addTrack(engine));
    result.define('deleteTrack', deleteTrack(engine));
    result.define('replaceTrack', replaceTrack(engine));
    result.define('loadMidiFile', loadMidiFile(engine));
    result.define('setTempo', setTempoFunc := setTempo(engine));
    result.define('set_tempo', setTempoFunc);
    result.define('resetPos', resetPos(engine));
    result.define('setPos', setPos(engine));
    result.define('addInputProcessor', addInputProcessor(engine));
    result.define('insertInputProcessor', insertInputProcessor(engine));
    result.define('removeInputProcessor', removeInputProcessor(engine));
    result.define('setInputChannel', setInputChannel(engine));
    result.define('addOutputProcessor', addOutputProcessor(engine));
    result.define('insertOutputProcessor', insertOutputProcessor(engine));
    result.define('removeOutputProcessor', removeOutputProcessor(engine));
    result.define('routeToOutputPort', routeToOutputPort(engine));
    result.define('routeToInstrument', routeToInstrument(engine));
    result.define('getCurrentSection', getCurrentSection(engine));
    result.define('copySection', copySection(engine));
    result.define('setMidiRecordTrackName', setMidiRecordTrackName(engine));
    result.define('createNewSection', createNewSection(engine));
    result.define('setSection', setSection(engine));

    return result;
}

## Compute the y value of a parabola with coefficients a, b, and c (standard
## form, "ax^2 + bx + c") for value x.
##
## In the context of audio processing, this is useful for translating linear
## controller values parabolically to effect parameters (for example, the Calf
## EQ has a minimum of 0.015625 and a maximum of 64 and we want that default
## to be about half way through the range).
@function float parabola(float a, float b, float c, float x) {
    return a * (x * x) + b * x + c;
}

## Returns base ** (exp_coefficient * x**2), which is useful for creating
## curves with very low ascent rates and very high values at the end of the
## range.
@function float curve1(float base, float exp_coefficient, float x) {
    return pow(base, exp_coefficient * x * x);
}

alias ObjArray = Array[Object];

## Given a mapping of a -> b expressed as an array of floats and a value
## ('val') corresponding to a value in 'a', returns the interpolated value in
## 'b'.  For example, for the mapping [1 -> 2, 2 -> 4, 3 -> 6] and a value of
## 2.5, this would return the value 5 (based on a lookup in the table and then
## linear interpolation between the two enclosing points 2 and 3.
##
## This can be used to obtain the inverse of any mapping curve (like curve1)
## given a generated set of values for the curve.
##
## 'vals' should be an array of floats with the a and b values interleaved, so
## the array in the example above would be [1, 2, 2, 4, 3, 6].  The values
## must be in ascending order.
@function Object interp(ObjArray vals, float val) {
    int bsearch(ObjArray vals, float val, int min, int max) {
        if (max - min <= 1)
            return min;

        mid := min + (max - min) / 2;
        cur := FloatObj.cast(vals[mid * 2]);
        if (val == cur.val)
            return mid;
        else if (val > cur.val)
            return bsearch(vals, val, mid, max);
        else
            return bsearch(vals, val, min, mid);
    }

    Object linear(ObjArray vals, int index, float desired) {
        a := FloatObj.cast(vals[index * 2]).val;
        ax := FloatObj.cast(vals[index * 2 + 1]).val;
        b := FloatObj.cast(vals[index * 2 + 2]).val;
        bx := FloatObj.cast(vals[index * 2 + 3]).val;
        pos := (desired - a) * (b - a);
        return FloatObj(ax + pos * (bx - ax));
    }

    index := bsearch(vals, val, 0, vals.count() / 2 - 1);
    cur := FloatObj.cast(vals[index * 2]);
    if (val == cur.val)
        return vals[index * 2 + 1];
    if (val < cur.val) {
        if (index == 0)
            return vals[1];
        return linear(vals, index - 1, val);
    } else {
        if (index == (vals.count() / 2) - 2)
            return vals.last();
        return linear(vals, index, val);
    }
}

class InterpWrapper {

    EvalContext __rootCtx = createRootContext();
    Poller __poller = {};

    @static void addCrashMethods(EvalContext ctx, AppMethods app) {
        ctx.define('collections', collections());
        ctx.define("stdlib", stdlib());

        ctx.define('play', play());
        ctx.define('exportMidiFile', ExportMidiFileCmd());
        ctx.define('getAWBEngine', get_engine());
        ctx.define('get_tempo', get_tempo());
        ctx.define('set_tempo', set_tempo());
        ctx.define('load', load());
        ctx.define('readWave', readWave());
        ctx.define('lengthenWave', lengthenWave());
        ctx.define('writeWave', writeWave());
        ctx.define('makeSequencerWaveModel', makeSequencerWaveModel());
        ctx.define('addWaveModel', addWaveModel());
        ctx.define('addMemFile', addMemFile());
        ctx.define('getTracks', getTracks());
        ctx.define('loadProject', loadProject());
        ctx.define('saveProject', saveProject());
        ctx.define('getOrchestra', getOrchestra());
        ctx.define('metro', metro());
        ctx.define('channel_connect', channelConnect());
        ctx.define('connect', connect());
        ctx.define('disconnect', disconnect());
        ctx.define('Ev_getValue', Ev_getValue());
        ctx.define('volumeControl', volumeControl());
        ctx.define('setVolume', setVolume());
        ctx.define('panControl', panControl());
        ctx.define('setPan', setPan());
        ctx.define('setGain', setGain());
        ctx.define('makeAudioFileRecorder', makeAudioFileRecorder());
        ctx.define('makeMidiTrackRecorder', makeMidiTrackRecorder());
        ctx.define('makeControllerOffsetChange',
                         makeControllerOffsetChange());
        ctx.define('NoteMapper', makeNoteMapper());
        ctx.define('ChannelMapper', makeChannelMapper());
        ctx.define('ChannelPredicate', makeChannelPredicate());
        ctx.define('bindController', bindController());
        ctx.define('addEventProcessor', addEventProcessor());
        ctx.define('ControllerDispatcher', makeControllerDispatcher());
        ctx.define('CrashEventProcessor', CrashEventProcessorCmd());
        ctx.define('seek', seek());
        ctx.define('shell', ShellCmd());
        ctx.define('tell', tell());
        ctx.define('fwd', fwd());
        ctx.define('bak', bak());
        ctx.define('app', makeAppWrapper(app));
        ctx.define('callback', CallbackCmd());
        ctx.define('evtrec', getEventRecModule());
        ctx.define('getCurrentSection', getCurrentSection());
        ctx.define('recordFile', recordFile());
        ctx.define('getRelativePath', getRelativePath());
        ctx.define('setLogLevel', setLogLevel_());
        ctx.define('prerr', prerr());
        ctx.define('className', className());
        ctx.define('CVR_MULT', SimpleValue(IntObj(CVR_MULT)));
        ctx.define('get_engine', get_engine());
        ctx.define('start_server', startServer());
        ctx.define('parabola', parabola());
        ctx.define('curve1', curve1());
        ctx.define('interp', interp());
        ctx.define('LEFT', SimpleValue(IntObj(LEFT)));
        ctx.define('RIGHT', SimpleValue(IntObj(RIGHT)));
        ctx.define('STEREO', SimpleValue(IntObj(LEFT | RIGHT)));
    }

    oper init(AppMethods app) {
        __poller.add(cin, POLLIN | POLLERR);

        addCrashMethods(__rootCtx, app);
    }

    void doREPL() {
        repl(__rootCtx);
    }

    void define(String name, Value value) {
        __rootCtx.define(name, value);
    }

    EvalContext getRootContext() { return __rootCtx; }

    void checkForInput() {
        if (__poller.wait(TimeDelta(0, 0))) {
            data := cin.read(1024);
            try {
                result := eval(data, __rootCtx);
                cout `$result\n`;
            } catch (Exception ex) {
                cout `got error: $ex\n`;
            }
            cout `>> `;
        }
    }

    void evalScript(String filename) {
        path := makePath(filename);
        __rootCtx.define('scriptDir',
                         SimpleValue(path.parent().getFullName())
                         );
        __rootCtx.define('scriptFile',
                         SimpleValue(path.getFullName())
                         );
        eval(path.readAll(), __rootCtx);
    }
}
