## Jack audio manager.

import crack.audio.wavfile readWave, ManagedWaveBuffer, WaveBuffer, WaveDef;
import crack.cont.array Array;
import crack.ext._jack JackClient, JackPort, JackPosition, JackClient_open,
    Jack_getDefaultAudioType, JACK_PORT_IS_OUTPUT, JACK_PORT_IS_INPUT,
    JACK_TRANSPORT_ROLLING;
import crack.fs makePath;
import crack.functor Function1, Functor1;
import crack.io cout, cerr, SeekableReader, SEEK_SET;
import crack.lang CString;
import crack.math max, abs;
import crack.runtime free, sleep;
import crack.threads Mutex, MutexLock, Thread;
import crack.time Time;

@import crack.ann implements;

@export_symbols JACK_TRANSPORT_ROLLING;

int jackCallback(uint32 nframes, voidptr arg);

class JackPos : Object, JackPosition {}

class JackWrapper {

    JackClient __client;
    JackPort left, right, left_in, right_in;

    ## The left and right buffers and the number of frames in each of them.
    ## These are only valid during a processor callback.
    uint32 frameCount;
    array[float] lbuf, rbuf;
    bool __paused;
    uint32 __startFrame;
    String __name = 'awb';

    Array[Functor1[void, JackWrapper]] __processors = {};

    oper init() {}
    oper init(String name) : __name = name {}

    void init() {
        array[int] status = {0};
        __client = JackClient_open(__name.buffer, 0, status);
        __client.setProcessCallback(jackCallback, this);
        left = __client.portRegister('left'.buffer, Jack_getDefaultAudioType(),
                                     JACK_PORT_IS_OUTPUT,
                                     4096
                                     );
        right = __client.portRegister('right'.buffer,
                                      Jack_getDefaultAudioType(),
                                      JACK_PORT_IS_OUTPUT,
                                      4096
                                      );
        left_in = __client.portRegister('left_in'.buffer,
                                        Jack_getDefaultAudioType(),
                                        JACK_PORT_IS_INPUT,
                                        4096
                                        );
        right_in = __client.portRegister('right_in'.buffer,
                                         Jack_getDefaultAudioType(),
                                         JACK_PORT_IS_INPUT,
                                         4096
                                         );
        cout `client is $__client\n`;
        free(status);
    }

    void addProcessor(Functor1[void, JackWrapper] processor) {
        __processors.append(processor);
    }

    @final void process(uint32 nframes) {
        lbuf = left.getBuffer(nframes);
        rbuf = right.getBuffer(nframes);

        for (int i; i < nframes; ++i) {
            lbuf[i] = 0;
            rbuf[i] = 0;
        }
        if (__paused) {
            # Clear both buffers and return.
            return;
        }
        frameCount = nframes;
        count := __processors.count();
        for (int i = 0; i < count; ++i)
            __processors[i](this);

        __startFrame += frameCount;
    }

    @final void activate() {
        cout `activating, client is $__client\n`;
        __client.activate();
    }

    @final void _showClient() {
        cout `showClient: client is $__client\n`;
    }

    @final void deactivate() {
        __client.deactivate();
    }

    ## Connect a source jack port to a destination jack port.
    ## Note that our client name is "awb" and our port names are:
    ##  left - left channel output
    ##  right - right channel output
    ##  left_in - left channel input
    ##  right_in - right channel input
    @final void connect(CString source, CString dest) {
        __client.connect(source.buffer, dest.buffer);
    }

    ## Pause playback/record.  Deactivate has the undesirable consequence of
    ## disconnecting all connected jack ports.  Pause just turns off
    ## processing from within the callback, so ports remain connected but they
    ## don't play or record.
    @final void pause() {
        __paused = true;
    }

    @final void unpause() {
        __paused = false;
    }

    ## Returns the jack client's sample rate.
    @final uint32 getSampleRate() { return __client.getSampleRate() }

    ## Returns the current start frame
    @final uint32 getStartFrame() { return __startFrame }

    # Sets the current start frame.
    @final void setStartFrame(uint32 startFrame) { __startFrame = startFrame }

    @final JackClient getClient() {
        return __client;
    }
}

## This is the jack callback.
int jackCallback(uint32 nframes, voidptr arg) {
    jack := JackWrapper.unsafeCast(arg);
    jack.process(nframes);
    return 0;
}

@abstract class WaveModel {

    ## Number of frames per chunk.  This must be constant for the entire model.
    int framesPerChunk;

    @abstract WaveBuffer getChunk(uint index);
}

## Jack callback processor that plays a WaveModel.
class WaveAdapter : Object @implements Functor1[void, JackWrapper] {

    uint pos;
    WaveModel model;

    oper init(WaveModel model) : model = model {}

    void oper call(JackWrapper wrapper) {
        lbuf := wrapper.lbuf;
        rbuf := wrapper.rbuf;
        curChunk := pos / model.framesPerChunk;
        chunk := model.getChunk(curChunk);
        start := pos;
        end := pos + wrapper.frameCount;
        float maxLeft, maxRight;
        for (; pos < end; ++pos) {
            newChunk := pos / model.framesPerChunk;
            if (newChunk != curChunk) {
                curChunk = newChunk;
                chunk = model.getChunk(curChunk);
            }
            lbuf[pos - start] =
                chunk.buffer[pos % model.framesPerChunk * 2] / 32768.0;
            rbuf[pos - start] =
                chunk.buffer[pos % model.framesPerChunk * 2 + 1] / 32768.0;
        }
    }
}

## A wave model that simply stores all of its backing buffers in memory.
class SimpleWaveModel : WaveModel {
    Array[WaveBuffer] buffers = {};
    WaveBuffer getChunk(uint index) {
        return buffers[index % buffers.count()];
    }
}

const BYTES_PER_SAMPLE := 2;

## WindowBuffer is a ring buffer for moving data from the file reader thread
## to the callbacks in the jack processing thread.
## This code isn't completely righteous with respect to threads: we can't
## block on a mutex in the jack process handler because of the risk of
## introducing latency, so we just read from the buffer and hope that our view
## of memory is mostly the same as that of the writer thread.  The only
## synchronization mechanism we use is for the two indexes (playPos and
## readPos) which are both atomic_int.
##
## The ring buffer typically maps to up to two pages of the sample sequence in
## the file:
##
##                  p  r
##                  |  |
##  --------------------------------------------------- absolute file pos
##             |          |          |                  ring buffer mappings
##              --------|x
##              ring buffer
##
## In the diagram, 'p' is playPos and 'r' is readPos.  Everything less than
## r % S (where 'S' is the size of the ring buffer) in the ring buffer maps to
## an absolute file position starting at B(r), where B(r) = (r // S) * S.  The
## rest of the buffer should generally map to the file position starting at
## B(r - S) (the previous frame), although this can vary after seeking to a
## new frame number.
class WindowBuffer {

    atomic_int
        ## The play position in samples.
        playPos,

        ## The absolute read position in samples.
        readPos,

        ## If nonzero, we're past the end of the data.
        pastEnd;

    atomic_int disableRead;

    ## The ring buffer.
    ManagedWaveBuffer ringBuf = {1024 * 1024};

    ## Start of the data in the file.
    uint dataStart;

    ## Number of tracks in the underlying file.
    int numTracks;

    WaveDef waveDef;
    SeekableReader src;

    ## Number of frames to read during a refresh.
    uint frames = 4096;

    oper init(WaveDef waveDef, SeekableReader src) :
        waveDef = waveDef,
        src = src,
        dataStart = src.tell(),
        numTracks = waveDef.channels {
    }

    @final void __clearRange(uint start, uint end) {
        for (int i = start; i < end; ++i)
            ringBuf.buffer[i] = 0;
    }

    @final void __noMoreData() {
        if (playPos < readPos && uintz(readPos - playPos) < ringBuf.cap) {
            # We haven't played the entire buffer yet, we can't clear all of
            # it.

            pp := playPos % ringBuf.cap;
            rp := readPos % ringBuf.cap;

            # Simplest case is where the remaining range doesn't wrap:
            #   pp     rp
            # |------------|
            #    |------|
            if (pp < rp) {
                __clearRange(0, pp);
                __clearRange(rp, ringBuf.cap);

            # Otherwise the range wraps and we need to clear out the middle:
            #   rp     pp
            # |------------|
            # ---|      |---
            } else {
                __clearRange(rp, pp);
            }

            return;
        }

        # Clear the ring buffer.
        __clearRange(0, ringBuf.cap);
        if (!pastEnd) pastEnd += 1;
    }

    ## Get the next chunk of data from the file into the ring buffer.
    ## Returns true if a refresh was done, false if no refresh was needed.
    bool refresh() {
        if (disableRead)
            return true;

        intz leading = readPos - playPos;
        if (leading > ringBuf.cap / 2 && leading <= ringBuf.cap)
            # XXX Also need to deal with the case where we're out of data in
            # the file somehow.
            return false;
        rp := uintz(readPos);
        pp := uintz(playPos);

        # Figure out how much to read.  Read the next chunk or up to the end
        # of the ring buffer.
        uint samplesToRead = frames * numTracks;
        samplesRemaining := (ringBuf.cap - rp % ringBuf.cap);
        if (samplesToRead > samplesRemaining)
            samplesToRead = samplesRemaining;

        if (leading < 0) {
            # We're already behind.  Start reading from the play position.
            cerr `fell behind by $leading samples\n`;
            rp = pp;
            if (src.seek(int64(rp * BYTES_PER_SAMPLE + dataStart), SEEK_SET) ==
                 -1
                ) {
                __noMoreData();
                return false;
            }
            readPos -= leading;
        }

        # We're more than a buffer-length ahead, back the read position up to
        # the play position.
        if (leading > ringBuf.cap) {
            cerr `backing up (rp = $rp, leading = $leading)\n`;
            rp = pp;
            if (src.seek(int64(rp * BYTES_PER_SAMPLE + dataStart), SEEK_SET) ==
                 -1
                ) {
                __noMoreData();
                return false;
            }

            # We can't currently set an atomic integer, so we adjust readPos
            # to be playPos by adding the negative difference.
            readPos += leading;
        }

#        cerr `reading $samplesToRead samples into $(rp % ringBuf.cap)\n`;
        WaveBuffer waveBuf = {samplesToRead, ringBuf.buffer + rp % ringBuf.cap};
        readPos += amtRead := waveDef.read(src, waveBuf);
#        cerr `  got $amtRead samples.  readPos is $readPos\n`;
        if (!amtRead)
            __noMoreData();
        else
            if (pastEnd) pastEnd -= 1;

        return amtRead;
    }

    void seek(uint frame) {
        playPos -= playPos - intz(frame * numTracks);
    }

    uint tell() {
        return playPos / numTracks;
    }

    ## Returns the frame count.
    @final uint getFrameCount() {
        return waveDef.frameCount;
    }

    ## Returns the rate (frmes per second).
    @final uint getRate() {
        return waveDef.rate;
    }
}

## This thread refreshes the WindowBuffers from their disk files.
class RefreshThread : Thread {
    Array[WindowBuffer] buffers = {};
    Mutex __mtx = {};

    void run() {
        while (true) {
            # Copy the window buffers from the mutex-protected 'buffers' array
            # before doing the time-consuming buffer refreshes.
            Array[WindowBuffer] curBufs;
            if (true) {
                t := Time.now();
                MutexLock lock = {__mtx};
                curBufs = buffers.clone();
#                cerr `refresh thread got lock: $(Time.now() - t)\n`;
            }
#            if (curBufs)
#                cerr `play pos: $(curBufs[0].playPos)\n`;
            bool refreshed = false;
            for (buf :in curBufs)
                refreshed = refreshed || buf.refresh();

            # All buffers are filled.
            if (!refreshed)
                sleep(1);
        }
    }

    void addBuffer(WindowBuffer buffer) {
        t := Time.now();
        MutexLock lock = {__mtx};
        cerr `addBuffer() got lock: $(Time.now() - t)\n`;
        buffers.append(buffer);
    }
}

## Allows a WindowBuffer (which maintains a ring of buffers and reads them
## from a wave file) to be used as a Jack processor.
class WindowBufferAdapter : Object @implements Functor1[void, JackWrapper] {

    WindowBuffer buf;
    float volume, gain;

    ## Array of pan values, one per track.  Pan values range from -1 (totally
    ## left) to +1 (totally right).
    array[float] pan;

    oper init(WindowBuffer buf) :
        buf = buf,
        pan = array[float](buf.numTracks),
        volume = 1.0,
        gain = 1.0 {

        for (int i; i < buf.numTracks; ++i)
            pan[i] = 0.0;
        if (buf.numTracks == 2) {
            pan[0] = -1;
            pan[1] = 1;
        }
    }

    oper del() {
        free(pan);
    }

    void oper call(JackWrapper wrapper) {
        for (int i; i < wrapper.frameCount; ++i) {
            absPos := buf.playPos + i * buf.numTracks;
            for (int j; j < buf.numTracks; ++j) {
                sample := buf.ringBuf[(absPos + j) % buf.ringBuf.cap] / 32768.0;
                if (pan[j] > 1.0 || pan[j] < -1.0)
                    cerr `\033[31mPan out of range: $(pan[j])\033[0m\n`;
                wrapper.lbuf[i] = wrapper.lbuf[i] +
                                  sample * volume * gain * ((1 - pan[j]) / 2);
                wrapper.rbuf[i] = wrapper.rbuf[i] +
                                  sample * volume * gain * ((1 + pan[j]) / 2);
            }
        }

        buf.playPos += wrapper.frameCount * buf.numTracks;
    }

    void seek(uint frame) {
        buf.seek(frame);
    }

    ## Returns the number of frames in the wave.
    @final uint getFrameCount() {
        return buf.getFrameCount();
    }

    ## Returns the track rate in frames per second.
    @final uint getRate() {
        return buf.getRate();
    }

    @final void setPan(float pan) {
        # TODO: support panning ranges.
        for (int i; i < buf.numTracks; ++i)
            this.pan[i] = pan;
    }

    ## Returns current "play position" (the number of frames since the wave
    ## file origin).  This is always aligned to the beginning of a jack
    ## buffer, but it should otherwise be fairly accurate WRT what is
    ## currently being played.
    @final intz getPos() { return buf.tell() }
}

## Clears the output buffers in the Jack wrapper.
void clearOutputBuffers(JackWrapper wrapper) {
    for (int i = 0; i < wrapper.frameCount; ++i) {
        wrapper.lbuf[i] = 0;
        wrapper.rbuf[i] = 0;
    }
}

class WaveManager : JackWrapper {

    Array[WindowBufferAdapter] wbas = {};
    RefreshThread refreshThread;

    oper init() {
        # Add a processor to clear the output buffers.
        # This has a special side-effect in that it allows us to force the
        # processor code to be jitted before a callback.
        addProcessor(Function1[void, JackWrapper](clearOutputBuffers));
    }

    @static WaveManager create() {
        # XXX If I move this into the constructor, I get seg faults.  This
        # appears to be a crack bug.

        # Basic initialization stuff.  This is all very order-sensitive due to
        # issues with jitting and jack callback latency - be careful.

        wm := WaveManager();
        wm.init();

        # This is a hack that forces the callback and all processing
        # functions to be JITted before we activate the event loop.  If we
        # don't do this, and we're running in JIT mode, they'll get JITted
        # during the first invocation of the callback, which will exceed the
        # jack timeout and cause jack to write off this client as a zombie.
        jackCallback(0, wm);

        wm.pause();
        wm._showClient();
        wm.activate();
        wm._showClient();
        return wm;
    }

    void addMemFile(String fileName) {
        src := makePath(fileName).reader();
        wd := readWave(src);
        wave := SimpleWaveModel();
        wave.framesPerChunk = 2048;
        buf := ManagedWaveBuffer(4096);
        while (wd.read(src, buf)) {
            wave.buffers.append(buf);
            buf = ManagedWaveBuffer(4096);
        }

        WaveAdapter waveAdapter = {null};
        waveAdapter.model = wave;
        addProcessor(waveAdapter);
    }

    WindowBufferAdapter addFile(String fileName) {
        src := makePath(fileName).reader();
        wd := readWave(src);
        buf := WindowBuffer(wd, src);

        # Fill the buffer.
        while (buf.refresh()) ;

        if (!refreshThread) {
            # Start a background thread to keep the buffer filled.
            refreshThread = RefreshThread();
            refreshThread.buffers.append(buf);
            refreshThread.start();
        } else {
            refreshThread.addBuffer(buf);
        }

        adapter := WindowBufferAdapter(buf);
        frameCount = 1;
        # Another hack to force precompilation of WindowBufferAdapter.
        adapter(this);
        addProcessor(adapter);
        wbas.append(adapter);

        return adapter;
    }

    void seek(uintz frame) {
        for (adapter :in wbas)
            adapter.seek(frame);
    }

    uintz tell() {
        return wbas ?  wbas[0].getPos() : 0;
    }

    ## Disables reads, leaving the window buffers to play from their loop.
    void disableRead() {
        int offset;
        if (wbas && wbas[0].buf.disableRead)
            offset = -1;
        else
            offset = 1;
        for (a :in wbas)
            a.buf.disableRead += offset;
    }
}
