## Jack audio manager.

import crack.audio.wavfile readWave, ManagedWaveBuffer, WaveBuffer, WaveDef;
import crack.cont.array Array;
import crack.ext._jack JackClient, JackPort, JackPosition, JackClient_open,
    Jack_getDefaultAudioType, JACK_PORT_IS_OUTPUT, JACK_PORT_IS_INPUT,
    JACK_TRANSPORT_ROLLING;
import crack.fs makePath;
import crack.functor Function1, Functor1;
import crack.io cout, cerr, FStr, Reader, SeekableReader, SeekableWriter,
    SEEK_SET;
import crack.lang Buffer, CString, Exception;
import crack.math max, abs;
import crack.runtime free, sleep;
import crack.threads Mutex, MutexLock, Thread;
import crack.time Time;

import .processors bufferFrameCount, AudioBuffer, BufferVector, Component;

@import crack.ann assert, cvars, impl, implements;

@export_symbols JACK_TRANSPORT_ROLLING;

int jackCallback(uint32 nframes, voidptr arg);

class JackPos : Object, JackPosition {}

class JackWrapper {

    JackClient __client;
    JackPort left, right, left_in, right_in;

    ## The left and right buffers and the number of frames in each of them.
    ## These are only valid during a processor callback.
    uint32 frameCount;
    array[float] lbuf, rbuf;
    bool __paused;
    uint32 __startFrame;
    String __name = 'awb';

    Array[Functor1[void, JackWrapper]] __processors = {};

    oper init() {}
    oper init(String name) : __name = name {}

    void init() {
        array[int] status = {0};
        __client = JackClient_open(__name.buffer, 0, status);
        __client.setProcessCallback(jackCallback, this);
        left = __client.portRegister('left'.buffer, Jack_getDefaultAudioType(),
                                     JACK_PORT_IS_OUTPUT,
                                     4096
                                     );
        right = __client.portRegister('right'.buffer,
                                      Jack_getDefaultAudioType(),
                                      JACK_PORT_IS_OUTPUT,
                                      4096
                                      );
        left_in = __client.portRegister('left_in'.buffer,
                                        Jack_getDefaultAudioType(),
                                        JACK_PORT_IS_INPUT,
                                        4096
                                        );
        right_in = __client.portRegister('right_in'.buffer,
                                         Jack_getDefaultAudioType(),
                                         JACK_PORT_IS_INPUT,
                                         4096
                                         );
        cout `client is $__client\n`;
        free(status);
    }

    void initDumb(uint32 nframes) {
        lbuf = array[float](nframes);
        rbuf = array[float](nframes);
        frameCount = nframes;
    }

    void addProcessor(Functor1[void, JackWrapper] processor) {
        __processors.append(processor);
    }

    void removeProcessor(Functor1[void, JackWrapper] processor) {
        for (iter :on __processors) {
            # Since we may be iterating over this loop, don't delete here,
            # just null them out.
            if (iter.elem() is processor)
                __processors[iter.index] = null;
        }
    }

    @final void clearBuffers(uint32 nframes) {
        for (int i; i < nframes; ++i) {
            lbuf[i] = 0;
            rbuf[i] = 0;
        }
    }

    @final void process(uint32 nframes) {
        lbuf = left.getBuffer(nframes);
        rbuf = right.getBuffer(nframes);

        clearBuffers(nframes);
        if (__paused) {
            # Clear both buffers and return.
            return;
        }
        frameCount = nframes;

        count := __processors.count();
        for (int i = 0; i < count;) {
            # Run any active processors, delete any nulled ones (see
            # removeProcessors()).
            proc := __processors[i];
            if (proc !is null) {
                proc(this);
                ++i;
            } else {
                __processors.delete(i);
                --count;
            }
        }

        __startFrame += frameCount;
    }

    ## Run all processors but without a connection to jackd.
    ##
    ## This exists to allow us to do audio rendering to a wave file without
    ## actually playing to the audio hardware.  This requires that the
    ## JackWrapper be initialized using initDumb() (you will get an
    ## AssertionError if not).
    @final void processDumb(uint32 nframes) {
        @assert(lbuf && rbuf);
        clearBuffers(nframes);
        for (p :in __processors)
            p(this);
        __startFrame += nframes;
    }

    @final void activate() {
        cout `activating, client is $__client\n`;
        __client.activate();
    }

    @final void _showClient() {
        cout `showClient: client is $__client\n`;
    }

    @final void deactivate() {
        __client.deactivate();
    }

    ## Connect a source jack port to a destination jack port.
    ## Note that our client name is "awb" and our port names are:
    ##  left - left channel output
    ##  right - right channel output
    ##  left_in - left channel input
    ##  right_in - right channel input
    @final void connect(CString source, CString dest) {
        __client.connect(source.buffer, dest.buffer);
    }

    ## Pause playback/record.  Deactivate has the undesirable consequence of
    ## disconnecting all connected jack ports.  Pause just turns off
    ## processing from within the callback, so ports remain connected but they
    ## don't play or record.
    @final void pause() {
        __paused = true;
    }

    @final void unpause() {
        __paused = false;
    }

    ## Returns the jack client's sample rate.
    @final uint32 getSampleRate() { return __client.getSampleRate() }

    ## Returns the current start frame
    @final uint32 getStartFrame() { return __startFrame }

    # Sets the current start frame.
    @final void setStartFrame(uint32 startFrame) { __startFrame = startFrame }

    @final JackClient getClient() {
        return __client;
    }

    ## Returns the array of processors.  These should be treated as immutable.
    ##
    ## TODO: These are currently accessed from non-jack threads, both here
    ## and from addProcessors().  This is dangerous and should be fixed.
    Array[Functor1[void, JackWrapper]] oper .processors() {
        return __processors;
    }
}

## This is the jack callback.
int jackCallback(uint32 nframes, voidptr arg) {
    jack := JackWrapper.unsafeCast(arg);
    try {
        jack.process(nframes);
    } catch (Exception ex) {
        cerr `Exception in jack thread: $ex\n`;
    }
    return 0;
}

class Mixer @impl Component {
    BufferVector buffers;

    ## Left buffer and right buffer, these can be set directly by the client.
    array[float] lbuf, rbuf;

    float volume = 1.0, gain = 1.0;
    bool __active = true;

    ## Array of pan values, one per track.  Pan values range from -1 (totally
    ## left) to +1 (totally right).
    Array[float] pan;

    oper init(int numTracks) : buffers(numTracks), pan(numTracks, 0) {
        for (int i = 0; i < numTracks; ++i)
            buffers.append(AudioBuffer(bufferFrameCount, 0));
        if (buffers.count() == 2) {
            pan[0] = -1;
            pan[1] = 1;
        }
    }

    int getInputChannelCount() {
        return buffers.count();
    }

    BufferVector getInputBuffers() {
        return buffers;
    }

    int getOutputChannelCount() {
        return 2;
    }

    void setOutputBuffers(BufferVector bufs) {
        @assert(bufs.count() == 2);
        lbuf = bufs[0].data();
        rbuf = bufs[1].data();
    }

    ## Sets the output buffers from the jack wrapper.
    void setOutputBuffers(JackWrapper jack) {
        lbuf = jack.lbuf;
        rbuf = jack.rbuf;
    }

    void run(int frameCount) {
        if (!__active)
            return;
        numTracks := buffers.count();
        for (int i; i < frameCount; ++i) {
            for (int j; j < numTracks; ++j) {
                sample := buffers[j][i];
                if (pan[j] > 1.0 || pan[j] < -1.0)
                    cerr `\033[31mPan out of range: $(pan[j])\033[0m\n`;
                lbuf[i] = lbuf[i] +
                          sample * volume * gain * ((1 - pan[j]) / 2);
                rbuf[i] = rbuf[i] +
                          sample * volume * gain * ((1 + pan[j]) / 2);
            }
        }
        if (_next)
            _next.run(frameCount);
    }

    void activate() {
        __active = true;
    }

    void deactivate() {
        __active = false;
    }
}

## A jack processor for PCM tracks.
##
## These have the following properties:
## - A current position in time.  Furthermore, they are "seekable", that is,
##   you can set the current position in time.
## - A component chain (see the processors module).
## - A mixer.
@abstract class PCMTrackAdapter @impl Functor1[void, JackWrapper] {
    Mixer mixer;

    # TODO: make this private so we can enforce input/output channels.
    Component headComponent;

    # If this is set to false, the adapter is disabled.
    bool __enabled = true;

    # The current "pan" value of the track.  This is really just a nominal
    # value, as the pan of individual channels can ultimately be overriden
    # through the mixer.  However, when setPan() is called, this value is
    # set (so that it can be returned through getPan()) and all of the
    # mixer channel pan values are overriden according to the panning
    # algorithm (currently just assigning channels a range of pan values
    # evenly spanning -__panRadius to +__panRadius).
    float __pan;

    # When panning a multi-channel track, the pan radius is
    float __panRadius = 1.0;

    ## channels: number of input channels of the final mixer.
    oper init(int channels) :
        mixer = Mixer(channels),
        headComponent = mixer {
    }

    @abstract void process(BufferVector bufs, uint32 frameCount);
    @abstract void _forward(uint frames);

    void oper call(JackWrapper wrapper) {
        if (__enabled) {
            input := headComponent.getInputBuffers();
            process(input, wrapper.frameCount);
            mixer.setOutputBuffers(wrapper);
            headComponent.run(wrapper.frameCount);
        }

        _forward(wrapper.frameCount);
    }

    @abstract void seek(uint frame);

    ## Returns the number of frames in the wave.
    @abstract uint getFrameCount();

    ## Returns the track rate in frames per second.
    @abstract uint getRate();

    ## Return the number of sub-tracks.
    @abstract uint getNumTracks();

    @final void setPan(float pan) {
        numTracks := getNumTracks();
        __pan = pan;
        if (numTracks == 1) {
            mixer.pan[0] = pan;
            return;
        }

        for (int i; i < numTracks; ++i) {

            # Compute the pan for the channel based on its position in the
            # range.
            p := pan - __panRadius +
                float(i) * __panRadius * 2 / float(numTracks - 1);
            if (p < -1.0)
                p = -1.0;
            else if (p > 1.0)
                p = 1.0;
            mixer.pan[i] = p;
        }
    }

    @final float getPan() { return __pan }

    ## Returns current "play position" (the number of frames since the wave
    ## file origin).  This is always aligned to the beginning of a jack
    ## buffer, but it should otherwise be fairly accurate WRT what is
    ## currently being played.
    @abstract intz getPos();

    ## Adds a new component to the head of the component chain.
    @final void insertComponent(Component component) {
        component.append(headComponent);
        headComponent = component;
    }

    ## Enable the adapter, causing it to play audio.
    @final void enable() {
        if (!__enabled) {
            if (headComponent)
                headComponent.activate();
            __enabled = true;
        }
    }

    ## Disable the adapter, turning off all audio from it.
    @final void disable() {
        if (__enabled) {
            if (headComponent)
                headComponent.deactivate();
            __enabled = false;
        }
    }

    ## Returns true if the adapter is enabled.
    @final bool enabled() {
        return __enabled;
    }
}

## A pass through adapter just adds a jack input to the mix (with volume,
## panning and effects like any other PCMTrackAdapter).
##
## This is a bit of an abuse of the PCMTrackAdapter concept, as it doesn't
## have a "position."  Don't add it as the first adapter along with real
## PCMTrackAdapaters.
class PassThroughAdapter : PCMTrackAdapter {
    Array[int] __inputIndex = Array[int]();
    JackWrapper __jack;

    oper init(JackWrapper jack, Array[String] inputs) :
        PCMTrackAdapter(inputs.count()),
        __jack = jack {

        for (input :in inputs) {
            if (input == 'left_in') {
                __inputIndex.append(0);
            } else if (input == 'right_in') {
                __inputIndex.append(1);
            } else {
                throw Exception(FStr() `Unknown input $input`);
            }
        }
    }

    void process(BufferVector bufs, uint32 frameCount) {
        for (inputIter :on __inputIndex) {
            buf := bufs[inputIter.index];
            inbuf := inputIter.elem() ?
                         __jack.right_in.getBuffer(frameCount) :
                         __jack.left_in.getBuffer(frameCount);
            for (uint32 i; i < frameCount; ++i)
                buf[i] = inbuf[i];
        }
    }

    void _forward(uint frames) {}
    void seek(uint frame) {}
    uint getFrameCount() { return 0 }
    uint getRate() { return __jack.getSampleRate() }
    uint getNumTracks() { return __inputIndex.count() }
    intz getPos() { return 0 }
}

@abstract class WaveModel {

    ## Read a sequence of samples into 'outputs'.
    ##
    ## pos: position (frame number) to read from.
    ## out: An output buffer.  This can be expected to be of size
    ##      frames * channels
    ## outputs: Set of buffers to read into.  It is safe to assume that the
    ##          number of buffers is the same as this.tracks.
    ## frames: Number of frames to read.
    @abstract void read(uint pos, WaveBuffer out, uint frames);

    ## Returns the total number of frames in the wave.
    @abstract uint oper .frames();

    ## Returns the number of channels in the wave.
    @abstract uint oper .channels();
}

## A WaveBuffer containing the full contents of a file and information on the
## number of channels.
class Wave : ManagedWaveBuffer {
    int channels;

    oper init(int channels, int cap) :
        channels = channels,
        ManagedWaveBuffer(cap) {
    }

    void grow(uintz newCap) {
        # If cap is currently enpty, just create a new buffer of the specified
        # capacity.
        if (cap == 0) {
            buffer = array[int16](newCap);
            cap = newCap;
            return;
        }

        # XXX I suspect this code may have some problems, when doing the check
        # incorrectly I'm getting memory corruption.
        if (newCap > cap) {
            newBuf := array[int16](newCap);
            for (int i = 0; i < size; ++i)
                newBuf[i] = buffer[i];
            free(buffer);
            buffer = newBuf;
            cap = newCap;
        }
    }

    ## Concatenate 'other' onto the end of this wave.
    void extend(WaveBuffer other) {
        if (size + other.size > cap)
            grow(cap * 2);
        for (int i = 0; i < other.size; ++i)
            buffer[size + i] = other.buffer[i];
        size = size + other.size;
    }

    ## Number of frames in the wave.
    uintz oper .frames() {
        return size / channels;
    }

    @static Wave read(Reader src) {
        def := readWave(src);
        buf := ManagedWaveBuffer(4096);
        wave := Wave(def.channels, def.frameCount * def.channels);
        while (def.read(src, buf))
            wave.extend(buf);
        return wave;
    }
}

## Jack callback processor that plays a WaveModel.
##
##
## Note that WaveModels are considered to be immutable once they're placed
## into a track, so we don't have to do all of the atomic jazz that we do in
## WindowBufferAdapter.
class WaveAdapter : PCMTrackAdapter {

    uint pos;
    WaveModel model;
    Wave __buf;

    oper init(WaveModel model) :
        PCMTrackAdapter(model.channels),
        model = model,
        __buf(model.channels, 4096) {
    }

    void process(BufferVector bufs, uint32 frameCount) {
        channels := model.channels;
        __buf.grow(frameCount * channels);
        model.read(pos, __buf, frameCount);
        for (int ch = 0; ch < channels; ++ch) {
            outBuf := bufs[ch];
            for (uint i; i < frameCount; ++i) {
                outBuf[i] = __buf[i * channels + ch] / 32768.0;
            }
        }
    }

    void _forward(uint frames) {
        pos += frames;
    }

    uint getFrameCount() { return model.frames }
    uint getNumTracks() { return model.channels }
    intz getPos() { return pos }

    ## Right now, all waves must be 44K.  This is just how it is.
    uint getRate() { return 44100 }

    void seek(uint frame) { pos = frame }
}

## A wave model that simply stores all of its backing buffers in memory.
class SimpleWaveModel : WaveModel {
    @cvars {
        Wave data;
    }

    void read(uint pos, WaveBuffer buf, uint frames) {
        for (i := 0; i < frames * data.channels; ++i)
            buf[i] = data[pos * data.channels + i];
    }

    uint oper .frames() {
        return data.size;
    }

    uint oper .channels() {
        return data.channels;
    }
}

## A wave model that is a proxy for a sequence of other wave buffers.
##
## As it stands, this is pretty simple.  The aim is for it to have a flexible
## interface so that we can do more advanced stuff with it.
class SequencerWaveModel : WaveModel {
    class PositionedBuffer {
        ## Start frame of the buffer
        uint start;

        ## Number of channels.
        int channels;

        WaveBuffer buf;

        oper init(uint start, int channels, WaveBuffer buf) :
            start = start,
            channels = channels,
            buf = buf {
        }

        int oper .end() { return buf.size / channels + start }

        bool overlaps(int start, int end) {
            return start < this.end && end > this.start;
        }

        @final int16 oper[](int index) {
            return buf[index];
        }

        uint oper .frames() { return buf.size / channels }
    }

    ## An array of buffers ordered by their start positions.
    Array[PositionedBuffer] __bufs = {};

    @static void __clearOutBuf(WaveBuffer out) {
        for (int i = 0; i < out.cap; ++i)
            out[i] = 0;
    }

    void __mixIn(int index, uint frames, PositionedBuffer pbuf,
                 WaveBuffer out
                 ) {
        offset := index - pbuf.start;

        # If we're already in the pbuf, then we start copying to the beginning
        # of the mex buf, otherwise we start from the first frame of the pbuf.
        start := offset >= 0 ? 0 : -offset;

        # If the end of the pbuf isn't until after the end of the mix buf,
        # then we end at the end position of the mixbuf.  Otherwise we end at
        # the last frame in the pbuf.
        end := pbuf.end > index + frames ? frames : pbuf.end - index;

        if (pbuf.channels == 1) {
            # if this is a single channel wave, copy the sample to the left
            # and right channels of the output buffer.
            for (i := start; i < end; ++i) {
                out[i * 2] = out[i * 2] + pbuf[i + offset];
                out[i * 2 + 1] = out[i * 2 + 1] + pbuf[i + offset];
            }
        } else {
            # For any other number of channels, copy the first two channels to
            # the two output channels and ignore the rest.
            for (i := start; i < end; ++i) {
                out[i * 2] = out[i * 2] + pbuf[(i + offset) * pbuf.channels];
                out[i * 2 + 1] = out[i * 2 + 1] +
                    pbuf[(i + offset) * pbuf.channels + 1];
            }
        }
    }

    ## Add a new positioned buffer to the model.
    void add(PositionedBuffer pbuf) {
        for (iter :on __bufs) {
            if (iter.elem().start > pbuf.start) {
                __bufs.insert(iter.index, pbuf);
                return;
            }
        }
        __bufs.append(pbuf);
    }

    uint oper .frames() { return __bufs ? __bufs[-1].end : 0 }

    ## Number of channels is always 2, which is kind of lame but adequate for
    ## now, since this model basically mixes everything to two channel anyway.
    uint oper .channels() { return 2 }

    void read(uint pos, WaveBuffer out, uint frames) {
        __clearOutBuf(out);
        for (pbuf :in __bufs) {
            # If the buffer starts after this chunk, we can quit.
            if (pos + frames < pbuf.start)
                break;

            if (pbuf.overlaps(pos, pos + frames))
                __mixIn(pos, frames, pbuf, out);
        }
    }
}


const BYTES_PER_SAMPLE := 2;

## WindowBuffer is a ring buffer for moving data from the file reader thread
## to the callbacks in the jack processing thread.
## This code isn't completely righteous with respect to threads: we can't
## block on a mutex in the jack process handler because of the risk of
## introducing latency, so we just read from the buffer and hope that our view
## of memory is mostly the same as that of the writer thread.  The only
## synchronization mechanism we use is for the two indexes (playPos and
## readPos) which are both atomic_int.
##
## The ring buffer typically maps to up to two pages of the sample sequence in
## the file:
##
##                  p  r
##                  |  |
##  --------------------------------------------------- absolute file pos
##             |          |          |                  ring buffer mappings
##              --------|x
##              ring buffer
##
## In the diagram, 'p' is playPos and 'r' is readPos.  Everything less than
## r % S (where 'S' is the size of the ring buffer) in the ring buffer maps to
## an absolute file position starting at B(r), where B(r) = (r // S) * S.  The
## rest of the buffer should generally map to the file position starting at
## B(r - S) (the previous frame), although this can vary after seeking to a
## new frame number.
class WindowBuffer {

    atomic_int
        ## The play position in samples.
        playPos,

        ## The absolute read position in samples.
        readPos,

        ## If nonzero, we're past the end of the data.
        pastEnd;

    atomic_int disableRead;

    ## The ring buffer.
    ManagedWaveBuffer ringBuf = {1024 * 1024};

    ## Start of the data in the file.
    uint dataStart;

    ## Number of tracks in the underlying file.
    int numTracks;

    WaveDef waveDef;
    SeekableReader src;

    ## Number of frames to read during a refresh.
    uint frames = 4096;

    oper init(WaveDef waveDef, SeekableReader src) :
        waveDef = waveDef,
        src = src,
        dataStart = src.tell(),
        numTracks = waveDef.channels {
    }

    @final void __clearRange(uint start, uint end) {
        for (int i = start; i < end; ++i)
            ringBuf.buffer[i] = 0;
    }

    @final void __noMoreData() {
        if (playPos < readPos && uintz(readPos - playPos) < ringBuf.cap) {
            # We haven't played the entire buffer yet, we can't clear all of
            # it.

            pp := playPos % ringBuf.cap;
            rp := readPos % ringBuf.cap;

            # Simplest case is where the remaining range doesn't wrap:
            #   pp     rp
            # |------------|
            #    |------|
            if (pp < rp) {
                __clearRange(0, pp);
                __clearRange(rp, ringBuf.cap);

            # Otherwise the range wraps and we need to clear out the middle:
            #   rp     pp
            # |------------|
            # ---|      |---
            } else {
                __clearRange(rp, pp);
            }

            return;
        }

        # Clear the ring buffer.
        __clearRange(0, ringBuf.cap);
        if (!pastEnd) pastEnd += 1;
    }

    ## Get the next chunk of data from the file into the ring buffer.
    ## Returns true if a refresh was done, false if no refresh was needed.
    bool refresh() {
        if (disableRead)
            return true;

        intz leading = readPos - playPos;
        if (leading > ringBuf.cap / 2 && leading <= ringBuf.cap)
            # XXX Also need to deal with the case where we're out of data in
            # the file somehow.
            return false;
        rp := uintz(readPos);
        pp := uintz(playPos);

        # Figure out how much to read.  Read the next chunk or up to the end
        # of the ring buffer.
        uint samplesToRead = frames * numTracks;
        samplesRemaining := (ringBuf.cap - rp % ringBuf.cap);
        if (samplesToRead > samplesRemaining)
            samplesToRead = samplesRemaining;

        if (leading < 0) {
            # We're already behind.  Start reading from the play position.
            cerr `fell behind by $leading samples\n`;
            rp = pp;
            if (src.seek(int64(rp * BYTES_PER_SAMPLE + dataStart), SEEK_SET) ==
                 -1
                ) {
                __noMoreData();
                return false;
            }
            readPos -= leading;
        }

        # We're more than a buffer-length ahead, back the read position up to
        # the play position.
        if (leading > ringBuf.cap) {
            cerr `backing up (rp = $rp, leading = $leading)\n`;
            rp = pp;
            if (src.seek(int64(rp * BYTES_PER_SAMPLE + dataStart), SEEK_SET) ==
                 -1
                ) {
                __noMoreData();
                return false;
            }

            # We can't currently set an atomic integer, so we adjust readPos
            # to be playPos by adding the negative difference.
            readPos += leading;
        }

#        cerr `reading $samplesToRead samples into $(rp % ringBuf.cap)\n`;
        WaveBuffer waveBuf = {samplesToRead, ringBuf.buffer + rp % ringBuf.cap};
        readPos += amtRead := waveDef.read(src, waveBuf);
#        cerr `  got $amtRead samples.  readPos is $readPos\n`;
        if (!amtRead)
            __noMoreData();
        else
            if (pastEnd) pastEnd -= 1;

        return amtRead;
    }

    void seek(uint frame) {
        playPos -= playPos - intz(frame * numTracks);
    }

    uint tell() {
        return playPos / numTracks;
    }

    ## Returns the frame count.
    @final uint getFrameCount() {
        return waveDef.frameCount;
    }

    ## Returns the rate (frmes per second).
    @final uint getRate() {
        return waveDef.rate;
    }
}

## This thread refreshes the WindowBuffers from their disk files.
class RefreshThread : Thread {
    Array[WindowBuffer] buffers = {};
    Mutex __mtx = {};

    void run() {
        while (true) {
            # Copy the window buffers from the mutex-protected 'buffers' array
            # before doing the time-consuming buffer refreshes.
            Array[WindowBuffer] curBufs;
            if (true) {
                t := Time.now();
                MutexLock lock = {__mtx};
                curBufs = buffers.clone();
#                cerr `refresh thread got lock: $(Time.now() - t)\n`;
            }
#            if (curBufs)
#                cerr `play pos: $(curBufs[0].playPos)\n`;
            bool refreshed = false;
            for (buf :in curBufs)
                refreshed = refreshed || buf.refresh();

            # All buffers are filled.
            if (!refreshed)
                sleep(1);
        }
    }

    void addBuffer(WindowBuffer buffer) {
        t := Time.now();
        MutexLock lock = {__mtx};
        cerr `addBuffer() got lock: $(Time.now() - t)\n`;
        buffers.append(buffer);
    }
}

## Allows a WindowBuffer (which maintains a ring of buffers and reads them
## from a wave file) to be used as a Jack processor.
class WindowBufferAdapter : PCMTrackAdapter {

    WindowBuffer buf;
    Component headComponent;

    oper init(WindowBuffer buf) :
        PCMTrackAdapter(buf.numTracks),
        buf = buf,
        headComponent = mixer {
    }

    void process(BufferVector bufs, uint32 frameCount) {
        for (int i; i < frameCount; ++i) {
            absPos := buf.playPos + i * buf.numTracks;
            for (int j; j < buf.numTracks; ++j) {
                sample :=
                    buf.ringBuf[(absPos + j) % buf.ringBuf.cap] / 32768.0;
                bufs[j][i] = sample;
            }
        }
    }

    void seek(uint frame) {
        buf.seek(frame);
    }

    void _forward(uint frames) {
        buf.playPos += frames * buf.numTracks;
    }

    ## Returns the number of frames in the wave.
    uint getFrameCount() { return buf.getFrameCount() }

    ## Returns the track rate in frames per second.
    uint getRate() { return buf.getRate() }

    uint getNumTracks() { return buf.numTracks }

    ## Returns current "play position" (the number of frames since the wave
    ## file origin).  This is always aligned to the beginning of a jack
    ## buffer, but it should otherwise be fairly accurate WRT what is
    ## currently being played.
    intz getPos() { return buf.tell() }
}

## Clears the output buffers in the Jack wrapper.
void clearOutputBuffers(JackWrapper wrapper) {
    for (int i = 0; i < wrapper.frameCount; ++i) {
        wrapper.lbuf[i] = 0;
        wrapper.rbuf[i] = 0;
    }
}

const int
    RECORD_RECORDING = 0,
    RECORD_FINISH_REQUESTED = 1,
    RECORD_FINISHED = 2;

## A buffer used for recording from jack.
class RecordBuffer {
    atomic_int

        # Record position, in samples.  This is the last position that we have
        # recorded up to.
        recordPos,

        ## The "saved position" which indicates the amount of the buffer that
        ## has been written to a file.
        savedPos,

        ## Set to nonzero when we're finished recording.
        finished;

    uint size = 1024 * 1024;
    array[int16] buffer = array[int16](1024 * 1024);

    void finish() {
        finished += 1;
    }
}

class Recorder @impl Functor1[void, JackWrapper] {

    @cvars {
        RecordBuffer outBuf;
    }

    void oper call(JackWrapper jack) {
        if (outBuf.finished) {
            jack.removeProcessor(this);
            return;
        }

        lbuf := jack.left_in.getBuffer(jack.frameCount);
        rbuf := jack.right_in.getBuffer(jack.frameCount);
        ol := jack.left.getBuffer(jack.frameCount);
        or := jack.right.getBuffer(jack.frameCount);

        for (int i; i < jack.frameCount; ++i) {
            outBuf.buffer[(outBuf.recordPos + i * 2) % outBuf.size] =
                int16(lbuf[i] * 32768.0);
            outBuf.buffer[(outBuf.recordPos + i * 2 + 1) % outBuf.size] =
                int16(rbuf[i] * 32768.0);
            ol[i] = ol[i] + lbuf[i];
            or[i] = or[i] + rbuf[i];

        }
        outBuf.recordPos += jack.frameCount * 2;
    }

    bool oper .finished() { return outBuf.finished }
}

const WriteThread_BUFSIZE := 4096;

## This thread writes its write buffers to a file.
##
## It should be constructed with a wave def whose header has been written.
class WriteThread : Thread {

    # Buffer that we transfer data into prior to writing.
    ManagedWaveBuffer writeFrame = ManagedWaveBuffer(WriteThread_BUFSIZE);

    @cvars {
        RecordBuffer buf;
        WaveDef def;
        SeekableWriter out;
    }

    void __fetch(uintz amount) {
        for (int i; i < amount; ++i)
            writeFrame[i] = buf.buffer[(buf.savedPos + i) % buf.size];
        writeFrame.size = uint(amount);
    }

    void run() {
        while (true) {
            while ((buf.recordPos - buf.savedPos >= int64(writeFrame.size)) ||
                   buf.finished
                   ) {
                if (buf.recordPos - buf.savedPos >= int64(writeFrame.size)) {
                    __fetch(writeFrame.cap);
                    def.writeData(out, writeFrame);
                    buf.savedPos += writeFrame.size;
                } else if (buf.finished) {
                    if (buf.recordPos < buf.savedPos) {
                        # Record the remaining chunk.  Note that we'll only
                        # ever get here if we end up with a partial buffer.
                        __fetch(buf.recordPos - buf.savedPos);
                        def.writeData(out, writeFrame);
                        buf.savedPos += writeFrame.size;
                    } else {
                        # Close out the file and terminate the thread.
                        def.finish(out);
                        return;
                    }
                }
            }
            sleep(1);
        }
    }
}

class WaveManager : JackWrapper {

    Array[PCMTrackAdapter] adapters = {};
    RefreshThread refreshThread;

    oper init() {
        # Add a processor to clear the output buffers.
        # This has a special side-effect in that it allows us to force the
        # processor code to be jitted before a callback.
        addProcessor(Function1[void, JackWrapper](clearOutputBuffers));
    }

    @static WaveManager create() {
        # XXX If I move this into the constructor, I get seg faults.  This
        # appears to be a crack bug.

        # Basic initialization stuff.  This is all very order-sensitive due to
        # issues with jitting and jack callback latency - be careful.

        wm := WaveManager();
        wm.init();

        # This is a hack that forces the callback and all processing
        # functions to be JITted before we activate the event loop.  If we
        # don't do this, and we're running in JIT mode, they'll get JITted
        # during the first invocation of the callback, which will exceed the
        # jack timeout and cause jack to write off this client as a zombie.
        jackCallback(0, wm);

        wm.pause();
        wm._showClient();
        wm.activate();
        wm._showClient();
        return wm;
    }

    WaveAdapter addMemFile(String fileName) {
        src := makePath(fileName).reader();
        wave := Wave.read(src);
        model := SimpleWaveModel(wave);
        addProcessor(result := WaveAdapter(model));
        adapters.append(result);
        return result;
    }

    ## Add a raw WaveModel.  This is most useful for adding a
    ## SequenceWaveModel.
    WaveAdapter addWaveModel(WaveModel model) {
        addProcessor(result := WaveAdapter(model));
        adapters.append(result);
        return result;
    }

    WindowBufferAdapter addFile(String fileName) {
        src := makePath(fileName).reader();
        wd := readWave(src);
        buf := WindowBuffer(wd, src);

        # Fill the buffer.
        while (buf.refresh()) ;

        if (!refreshThread) {
            # Start a background thread to keep the buffer filled.
            refreshThread = RefreshThread();
            refreshThread.buffers.append(buf);
            refreshThread.start();
        } else {
            refreshThread.addBuffer(buf);
        }

        adapter := WindowBufferAdapter(buf);
        frameCount = 1;
        # Another hack to force precompilation of WindowBufferAdapter.
        adapter(this);
        addProcessor(adapter);
        adapters.append(adapter);

        return adapter;
    }

    ## Add a "pass-through" adapter for the given jack inputs.
    PassThroughAdapter addPassThrough(Array[String] inputs) {
        adapter := PassThroughAdapter(this, inputs);
        adapter(this);
        addProcessor(adapter);
        adapters.append(adapter);
        return adapter;
    }

    void seek(uintz frame) {
        for (adapter :in adapters)
            adapter.seek(frame);
    }

    uintz tell() {
        return adapters ? adapters[0].getPos() : 0;
    }

    ## Begin recording.  To end the record call the finish() method on the
    ## returned RecordBuffer.
    ## 'def' should have been initialized with def.writeHeader(out);
    RecordBuffer beginRecord(WaveDef def, SeekableWriter out) {
        buf := RecordBuffer();
        recorder := Recorder(buf);
        WriteThread(buf, def, out).start();
        addProcessor(Recorder(buf));

        return buf;
    }

    ## Returns true if there are any active adapters or recorders.
    bool hasTracks() {
        if (adapters)
            return true;

        for (proc :in processors) {
            if ((rec := Recorder.cast(proc, null)) && !rec.finished)
                return true;
        }

        return false;
    }
}
