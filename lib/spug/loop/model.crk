# Copyright 2012 Google Inc.  All Rights Reserved.
#
# Spugloop model objects.

import crack.cont.array Array;
import crack.fs cwd, makePath;
import crack.io cout, FStr, StringReader, StringWriter;
import crack.lang Exception;
import crack.midi.event ChannelEvent, EndTrack, Event, MidiReader,
    MidiWriter, ProgramChange, SeekableEventSource, Track;
import spug.loop.instrument Instrument;
import spug.loop.jack WaveManager;
import crack.midi.alsa Sequencer;
import crack.serial SerialReader, SerialWriter;
import crack.time Time;

@import crack.ann assert, interface;

## This is a "section" of the piece.  A section consists of a group of tracks
## that are played in parallel.  A section consists of one or more "measures"
## which should normally be the size of the shortest track.  Every track
## should completely fill some number of measures.
class Section {

    ## The size of a measure in pulses.  A value of zero is used when there
    ## are no tracks.
    uint measure;

    ## The time span of the section in pulses.
    uint span;

    ## The set of all tracks in the section.
    Array[Track] tracks;

    oper init() : tracks() {}
    oper init(Array[Track] tracks, uint measure, uint span) :
        tracks = tracks,
        measure = measure,
        span = span {
    }

    ## Records the "end of track" time.  If there is only one track it also
    ## sets the measure time.
    ## If 'snapToMeasure' is true, snap the end time and events to the nearest
    ## measure boundary.  That is to say, it changes the end time to the end of the last
    ## measure if that is closer than then end of the next measure and
    ## moves all events past the end of the last measure back to align with
    ## the ending.
    @final void markEnding(Track lastTrack, uint time, bool snapToMeasure) {

        if (!span) {
            span = measure = time;
        # verify that the time is an even multiple of the current span
        } else {

            # if the end time is closer to the beginning of the measure than
            # to the end, trim all events to the end of the measure boundary.
            timeInMeasure := time % measure;
            if (timeInMeasure < measure - timeInMeasure) {
                time -= timeInMeasure;
                for (event :in lastTrack)
                    if (event.time > time)
                        event.time = time;
            }

            if (time > span) {
                cout `increasing span: $time / $span\n`;
                multiple := (time - 1) / span + 1;
                span *= multiple;
            }
            time = span;
        }

        lastTrack.add(EndTrack(time));
    }

    @final void deleteTrack(uint index) {
        tracks.delete(index);

        # deal with deleting the last track.
        if (!tracks.count()) {
            span = measure = 0;
            return;
        }

        # recalculate the span
        maxSpan := 0;
        uint t;
        for (track :in tracks) {
            t = track[-1].time;
            if (t > maxSpan)
                maxSpan = t;
        }
        span = t;
    }

    void writeTo(SerialWriter out) {
        out.write(measure);
        out.write(span);
        out.write(tracks.count());

        for (track :in tracks) {

            # write the track name
            out.write(track.name);

            # serialize the track, then write it out as a string since tracks
            # are not delimited.
            StringWriter temp = {};
            MidiWriter mw = {temp};
            track.writeTo(mw);
            mw.flush();
            out.write(temp.makeString());
        }
    }

    void readFrom(SerialReader src) {
        measure = src.readUInt();
        span = src.readUInt();
        trackCount := src.readUInt();

        for (int i = 0; i < trackCount; ++i) {
            trackName := src.readString();
            MidiReader mr = {StringReader(src.readString())};
            tracks.append(track := mr.readTrack(trackName));
            cout `track $i:\n$track\n`;
        }
    }
}

## Global play modes.
const int IDLE = 0, RECORD = 1, PLAY = 2, LATCHED_RECORD = 3;

## This is the main class representing a project.
class Project {
    Array[Section] sections = {};

    ## The next section number that hasn't been used as part of a section name.
    int nextSectionNumber;

    ## Write the current project to a file.
    void writeTo(SerialWriter out) {
        # version number
        out.write(1);

        # write the section count, then each of the sections.
        out.write(sections.count());
        for (section :in sections)
            section.writeTo(out);
    }

    void readFrom(SerialReader src) {
        sections.clear();
        if ((v := src.readUInt()) != 1)
            throw Exception(FStr() `Invalid varsion number: $v`);
        sectionCount := src.readUInt();
        for (i := 0; i < sectionCount; ++i) {
            section := Section();
            section.readFrom(src);
            sections.append(section);
        }
    }
}

@interface Controller {
    @abstract void changeState(int oldState, int newState);
    @abstract void trackAdded();
    @abstract void trackDeleted(uint index);
    @abstract void sectionCreated();
    @abstract void sectionChanged();
}

Array[String] programNames = [
    'Acoustic Grand Piano',
    'Bright Acoustic Piano',
    'Electric Grand Piano',
    'Honky-tonk Piano',
    'Electric Piano 1',
    'Electric Piano 2',
    'Harpsichord',
    'Clavi',
    'Celesta',
    'Glockenspiel',
    'Music Box',
    'Vibraphone',
    'Marimba',
    'Xylophone',
    'Tubular Bells',
    'Dulcimer',
    'Drawbar Organ',
    'Percussive Organ	',
    'Rock Organ',
    'Church Organ',
    'Reed Organ',
    'Accordion',
    'Harmonica',
    'Tango Accordion',
    'Acoustic Guitar (nylon)',
    'Acoustic Guitar (steel)',
    'Electric Guitar (jazz)',
    'Electric Guitar (clean)',
    'Electric Guitar (muted)',
    'Overdriven Guitar',
    'Distortion Guitar',
    'Guitar harmonics',
    'Acoustic Bass',
    'Electric Bass (finger)',
    'Electric Bass (pick)',
    'Fretless Bass',
    'Slap Bass 1	',
    'Slap Bass 2	',
    'Synth Bass 1',
    'Synth Bass 2',
    'Violin',
    'Viola',
    'Cello',
    'Contrabass',
    'Tremolo Strings',
    'Pizzicato Strings',
    'Orchestral Harp',
    'Timpani',
    'String Ensemble 1',
    'String Ensemble 2',
    'SynthStrings 1',
    'SynthStrings 2',
    'Choir Aahs',
    'Voice Oohs',
    'Synth Voice',
    'Orchestra Hit',
    'Trumpet',
    'Trombone',
    'Tuba',
    'Muted Trumpet',
    'French Horn',
    'Brass Section',
    'SynthBrass 1',
    'SynthBrass 2',
    'Soprano Sax',
    'Alto Sax',
    'Tenor Sax',
    'Baritone Sax',
    'Oboe',
    'English Horn',
    'Bassoon',
    'Clarinet',
    'Piccolo',
    'Flute',
    'Recorder',
    'Pan Flute',
    'Blown Bottle',
    'Shakuhachi',
    'Whistle',
    'Ocarina',
    'Lead 1 (square)',
    'Lead 2 (sawtooth)',
    'Lead 3 (calliope)',
    'Lead 4 (chiff)',
    'Lead 5 (charang)',
    'Lead 6 (voice)',
    'Lead 7 (fifths)',
    'Lead 8 (bass + lead)',
    'Pad 1 (new age)',
    'Pad 2 (warm)',
    'Pad 3 (polysynth)',
    'Pad 4 (choir)',
    'Pad 5 (bowed)',
    'Pad 6 (metallic)',
    'Pad 7 (halo)',
    'Pad 8 (sweep)',
    'FX 1 (rain)',
    'FX 2 (soundtrack)',
    'FX 3 (crystal)',
    'FX 4 (atmosphere)',
    'FX 5 (brightness)',
    'FX 6 (goblins)',
    'FX 7 (echoes)',
    'FX 8 (sci-fi)',
    'Sitar',
    'Banjo',
    'Shamisen',
    'Koto',
    'Kalimba',
    'Bag pipe',
    'Fiddle',
    'Shanai',
    'Tinkle Bell',
    'Agogo',
    'Steel Drums',
    'Woodblock',
    'Taiko Drum',
    'Melodic Tom',
    'Synth Drum',
    'Reverse Cymbal',
    'Guitar Fret Noise',
    'Breath Noise',
    'Seashore',
    'Bird Tweet',
    'Telephone Ring',
    'Helicopter',
    'Applause',
    'Gunshot',

    # 128 - fake programs
    'Drumz',
];

class ChannelInfo {
    byte program;

    oper init(byte program) : program = program {}
    String getProgramName() { return programNames[program]; }
}

class ChannelMap {
    byte currentChannel;
    Array[ChannelInfo] programs = [
        ChannelInfo(0), # 0 Grand Piano
        ChannelInfo(32), # 1 Bass
        ChannelInfo(48), # 2 strings
        ChannelInfo(18), # 3 Rock Organ
        ChannelInfo(3),  # 4 Honky Tonk
        ChannelInfo(80), # 5 Synth (square)
        ChannelInfo(30), # 6 Overdrive Guitar
        ChannelInfo(66), # 7 Tenor Sax
        ChannelInfo(62), # 8 Brass Section
        ChannelInfo(128), # channel 9, this is going to be drums
    ];

    ChannelInfo getCurrentChannel() { return programs[currentChannel]; }
}

class LoopCursor {
    Track track;
    int index;

    # time of the current position and span of the entire track.
    uint time, span;
    oper init(Track track) : track = track {
        time = track[0].time;

        # make sure our last event is an EndTrack and there is at least one
        # other event in the track.
        EndTrack.cast(track[-1]);
        @assert(track.count() > 1);
        span = track[-1].time;
    }

    Event next() {
        cur := track[index];
        ++index;
        if (index == track.count() - 1) {
            # make sure we are at an end event.
            EndTrack.cast(track[index]);
            index = 0;
        }
        time = track[index].time;
        return cur;
    }

    bool immediatelyFollows(uint pos) {
        if (index == 0) {
            # the last event is the end track marker, check to see that pos is
            # either greater than the /next to last/ event or less than the
            # current one.
            return pos >= track[-2].time || pos < time;
        } else {
            # if this isn't the first track, we just need to verify that pos
            # is between the last event and the current one.
            return pos < time && pos >= track[index - 1].time;
        }
    }

    void setPos(uint pos) {
        while (!immediatelyFollows(pos)) next();
    }
}

const MILLION := 1000000;
const BILLION := MILLION * 1000;

## The event manager deals with all of the scheduling and event dispatching.
class EventManager {
    Controller controller;
    Instrument instrument;
    Sequencer sequencer;
    ChannelMap channelMap;

    # initialize to default project.
    Project project = {};

    Section curSection = {};
    int curSectionIndex, nextSectionIndex;
    Track recordTrack;
    Array[LoopCursor] trackCursors;

    # Name of the project file.
    String projectFileName = 'noname';

    # The wave manager.  Manages the direct PCM wave system.
    WaveManager waveMan;

    int mode;

    # time that the current loop started and a holder for the current time.
    Time startTime = {}, t = {};

    # last time that we acted upon.
    float lastTime;

    # if nextSectionIndex is true, this is the next time to change the section
    uint nextSectionStartTime;

    # Both Tempo and PPB should be defined per section.  Per-section tempo
    # should be defined relative to the project tempo, tempo should be in the
    # project, what we have here should probably be either a scaling factor or
    # an override of the project level value.

    ## Global tempo in BPM.
    uint tempo = 120;

    ## Global pulses-per-beat.
    uint ppb = 96;

    oper init(Controller controller, Instrument instrument,
              Sequencer sequencer,
              ChannelMap channelMap
              ) :
        controller = controller,
        instrument = instrument,
        sequencer = sequencer,
        channelMap = channelMap {

        project.sections.append(curSection);

        # set up the programs for the synthesizer
        byte i;
        for (chi :in channelMap.programs) {
            instrument.onEvent(ProgramChange(0, i, chi.program & 0x7F));
            ++i;
        }
    }

    ## Returns the number of midi clock ticks (aka "pulses") for the specified
    ## number of microseconds.
    @final int usecsToTicks(int64 usecs) {
        # This is a bit convoluted because we're trying to do it with integer
        # math without truncating anything signficant.  What we're trying to say
        # is: seconds * pulsesPerSecond
        # where: pulsesPerSecond = (BPM / 60) * PPB
        #        seconds = usecs / MILLION
        # so: (usecs / MILLION) * ((BPM / 60) * PPB)
        #     (usecs / MILLION) * ((BPM * PPB) / 60)
        #     (usecs * BPM * PPB) / (60 * MILLION)
        return (usecs * int64(tempo) * int64(ppb)) / int64(60 * MILLION);
    }

    int64 ticksToUSecs(int ticks) {
        # This just inverts the math above:
        #   ticks = (nsecs * BPM * PPB) / (60 * MILLION)
        # so:
        #   (ticks * 60 * MILLION) / (BPM * PPB) = nsecs
        return (60 * MILLION * ticks) / (tempo * ppb);
    }

    ## Record the current time as the start time.
    void markStartTime() {
        startTime.setToNow(null);
    }

    ## Returns the time relative to when we started looping (also in ticks).
    uint getRelTime() {
        t.setToNow(null);
        int64 usecs = int64(t.secs - startTime.secs) * MILLION +
                      (t.nsecs - startTime.nsecs) / 1000;
        result := usecsToTicks(usecs);
        return result;
    }

    ## Adds a track to the current section, notifies the controller.
    void addTrack(Track track, uint endTime) {
        curSection.markEnding(track, endTime, true);
        curSection.tracks.append(track);
        controller.trackAdded();
    }

    void endRecord() {
        addTrack(recordTrack, getRelTime());
        trackCursors = null;
        recordTrack = null;
    }

    void doRecord() {
        controller.changeState(mode, RECORD);
        if (mode == RECORD)
            endRecord();
        cout `record\n`;

        # if we're coming in from "latched" mode, adjust the start time
        if (mode == LATCHED_RECORD && startTime.secs && curSection.span) {
            usecs := ticksToUSecs((getRelTime() / curSection.span) *
                                  curSection.span);
            startTime.nsecs += int32((usecs % MILLION) * 1000);
            startTime.secs += int32(usecs / MILLION +
                                    startTime.nsecs / BILLION);
        } else {
            # otherwise, just reset it.
            markStartTime();
        }
        mode = RECORD;
        recordTrack = Track(channelMap.getCurrentChannel().getProgramName());
    }

    void doLatchedRecord() {
        # XXX going from play -> latched seems to be broken
        cout `latched\n`;
        if (mode == RECORD)
            endRecord();
        mode = LATCHED_RECORD;
    }

    void doIdle() {
        cout `idle\n`;
        instrument.stop();
        controller.changeState(PLAY, IDLE);
        mode = IDLE;
        trackCursors = null;
        if (waveMan)
            waveMan.deactivate();
    }

    void setTrackCursors(uint ticks) {
        if (trackCursors) {
            for (cur :in trackCursors)
                cur.setPos(ticks);
        }
    }

    ## Sets our current position within the section.
    void setPos(uint ticks) {
        markStartTime();
        setTrackCursors(ticks);
    }

    void doPlay() {
        if (!curSection.tracks && mode != RECORD && !waveMan) {
            cout `No tracks to play!\n`;
            return;
        }

        cout `play\n`;
        controller.changeState(mode, PLAY);

        if (mode == RECORD)
            endRecord();
        mode = PLAY;
        setPos(0);
        if (waveMan)
            waveMan.activate();
    }

    void doStop() {
        if (mode == RECORD)
            endRecord();

        mode = IDLE;
        if (waveMan)
            waveMan.deactivate();
    }

    void togglePlay() {
        if (mode == PLAY)
            doIdle();
        else
            doPlay();
    }

    ## restore the app to its pristine state
    void clear() {
        cout `clearing state\n`;
        recordTrack = null;
        mode = IDLE;
        startTime.secs = startTime.nsecs = 0;
        project = Project();
        curSection = Section();
        project.sections.append(curSection);
    }


    void onInputEvent(Event event) {
        if (mode == LATCHED_RECORD)
            doRecord();

        event.time = getRelTime();
        if (chev := ChannelEvent.cast(event, null))
            chev.channel = channelMap.currentChannel;
        cout `adding event with time $(event.time): $event\n`;
        instrument.onEvent(event);
        if (mode == RECORD)
            recordTrack.append(event);
    }

    void __playPendingEvents(LoopCursor cur, uint pos) {
        while (!cur.immediatelyFollows(pos)) {
            instrument.onEvent(e := cur.next());
#            cout `played event $e at time $(e.time)/$(cur.span) for pos $pos\n`;
        }
    }

    void deleteTrack(uint index) {
        trackChannel := ChannelEvent.cast(curSection.tracks[index][0]).channel;
        instrument.getChild(trackChannel).stop();
        curSection.deleteTrack(index);
        if (trackCursors)
            trackCursors.delete(index);

        # tell the controller
        controller.trackDeleted(index);
    }

    void __changeSection() {
        curSectionIndex = nextSectionIndex;
        curSection = project.sections[curSectionIndex];
        trackCursors = null;
        controller.sectionChanged();
    }

    ## Change the section at the end of the next loop or immediately if we're
    ## idle.
    void __scheduleSectionChange() {
        if (mode == IDLE)
            __changeSection();
        else {
            relTime := getRelTime();
            nextSectionStartTime =
                (relTime / curSection.span + 1) * curSection.span;
        }
    }

    ## Create a new section.  If we're in "play" mode, make the new section
    ## the next section to play.
    ## seedTracks: tracks to seed the new section with.
    void createSection(Array[Track] seedTracks) {
        nextSectionIndex = project.sections.count();

        # if there are seed tracks, use the current section's measure and
        # obtain the span from the seed track.  Otherwise just create an empty
        # section.
        Section newSection;
        if (seedTracks) {
            uint span;
            for (track :in seedTracks) {
                t := track[-1].time;
                if (t > span)
                    span = t;
            }
            newSection = Section(seedTracks, curSection.measure, span);
        } else {
            newSection = Section();
        }

        project.sections.append(newSection);

        controller.sectionCreated();
        __scheduleSectionChange();
    }

    int getSectionCount() { return project.sections.count(); }
    int getSectionIndex() { return curSectionIndex; }
    int getNextSectionIndex() { return nextSectionIndex; }
    void setNextSection(int index) {
        nextSectionIndex = index;
        __scheduleSectionChange();
    }

    void runOneCycle() {
        relTime := getRelTime();

        # see if we need to change sections.
        if ((nextSectionIndex != curSectionIndex) && mode == PLAY &&
            relTime >= nextSectionStartTime
            ) {
            instrument.stop();
            __changeSection();
            markStartTime();
        }

        # Check for a incoming events on the sequencer, play it and store it
        # if we're recording.
        while (sequencer.hasEvent()) {
            event := sequencer.getEvent();
            if (event)
                onInputEvent(event);
        }

        # if we're recording, get the next event.
        if (mode == RECORD || mode == PLAY || mode == LATCHED_RECORD) {

            # if we don't currently have a set of cursors, generate them now.
            if (!trackCursors && curSection.tracks) {
                trackCursors =
                    Array[LoopCursor](curSection.tracks.count());
                for (track :in curSection.tracks)
                    trackCursors.append(LoopCursor(track));
            }

            if (trackCursors) {
                # play all of the events in all of the tracks that are due to
                # be played.
                for (cur :in trackCursors) {
                    # safety check
                    if (!cur.span)
                        continue;

                    # calculate the point we're at in this track.
                    trackPos := relTime % cur.span;

                    # play all events up to that point
                    __playPendingEvents(cur, trackPos);
                }
            }
        }

        lastTime = relTime;
    }

    ## Returns the fraction of time position / section span as of the last
    ## runOneCycle().
    float getTimeFraction() {
        return (lastTime % curSection.span) / curSection.span;
    }

    ## Returns true if we're playing existing tracks (either as play or
    ## record).
    @final bool playingExistingTracks() {
        return mode == PLAY ||
               (mode == RECORD || mode == LATCHED_RECORD) && curSection.tracks;
    }

    ## Store the track to the current filename.
    void save() {
        project.writeTo(SerialWriter(makePath(projectFileName).writer()));
    }

    ## Load the track and set the filename.  Does nothing if the file doesn't
    ## exist.
    void load(String filename) {
        projectFileName = filename;
        path := makePath(filename);
        if (path.exists()) {
            project.readFrom(SerialReader(path.reader()));
            curSection = project.sections[0];
            cout `tracks in cur section: $(curSection.tracks.count())\n`;
            controller.sectionChanged();
        }
    }
}
