# Copyright 2012 Google Inc.  All Rights Reserved.
#
# Spugloop model objects.

import crack.cont.array Array;
import crack.fs cwd;
import crack.io cout, FStr;
import crack.midi.event ChannelEvent, EndTrack, Event, MidiWriter, ProgramChange,
    SeekableEventSource, Track;
import spug.loop.instrument Instrument;
import crack.midi.alsa Sequencer;
import crack.time Time;

@import crack.ann assert, interface;

## This is a "section" of the piece.  A section consists of a group of tracks
## that are played in parallel.  A section consists of one or more "measures"
## which should normally be the size of the shortest track.  Every track
## should completely fill some number of measures.
class Section {

    ## The size of a measure in pulses.  A value of zero is used when there
    ## are no tracks.
    uint measure;

    ## The time span of the section in pulses.
    uint span;

    ## The set of all tracks in the section.
    Array[Track] tracks = {};

    ## The next track number that hasn't been used as part of a name.
    int nextTrackNumber;

    ## Records the "end of track" time.  This is a no-op if there is more than
    ## one track, if there is only one track it sets the measure time.
    @final void markEnding(Track lastTrack, uint time) {

        if (!span) {
            span = measure = time;
        # verify that the time is an even multiple of the current span
        } else {
            if (time > span) {
                cout `increasing span: $time / $span\n`;
                multiple := (time - 1) / span + 1;
                span *= multiple;
            }
            time = span;
        }

        lastTrack.add(EndTrack(time));
    }

    @final void deleteTrack(uint index) {
        tracks.delete(index);

        # recalculate the span
        maxSpan := 0;
        uint t;
        for (track :in tracks) {
            t = track[-1].time;
            if (t > maxSpan)
                maxSpan = t;
        }
        span = t;
    }
}

## Global play modes.
const int IDLE = 0, RECORD = 1, PLAY = 2, LATCHED_RECORD = 3;

## This is the main class representing a project.
class Project {
    Array[Section] sections = {};

    ## The next section number that hasn't been used as part of a section name.
    int nextSectionNumber;
}

@interface Controller {
    @abstract void changeState(int oldState, int newState);
    @abstract void trackAdded();
    @abstract void trackDeleted(uint index);
}

class ChannelInfo {
    byte program;

    oper init(byte program) : program = program {}
}

class ChannelMap {
    byte currentChannel;
    Array[ChannelInfo] programs = [
        ChannelInfo(0), # 0 Grand Piano
        ChannelInfo(32), # 1 Bass
        ChannelInfo(48), # 2 strings
        ChannelInfo(18), # 3 Rock Organ
        ChannelInfo(3),  # 4 Honky Tonk
        ChannelInfo(80), # 5 Synth (square)
        ChannelInfo(30), # 6 Overdrive Guitar
        ChannelInfo(66), # 7 Tenor Sax
        ChannelInfo(62), # 8 Brass Section
        ChannelInfo(0),  # channel 9, this is going to be drums
    ];
}

class LoopCursor {
    Track track;
    int index;

    # time of the current position and span of the entire track.
    uint time, span;
    oper init(Track track) : track = track {
        time = track[0].time;

        # make sure our last event is an EndTrack and there is at least one
        # other event in the track.
        EndTrack.cast(track[-1]);
        @assert(track.count() > 1);
        span = track[-1].time;
    }

    Event next() {
        cur := track[index];
        ++index;
        if (index == track.count() - 1) {
            # make sure we are at an end event.
            EndTrack.cast(track[index]);
            index = 0;
        }
        time = track[index].time;
        return cur;
    }

    bool immediatelyFollows(uint pos) {
        if (index == 0) {
            # the last event is the end track marker, check to see that pos is
            # either greater than the /next to last/ event or less than the
            # current one.
            return pos >= track[-2].time || pos < time;
        } else {
            # if this isn't the first track, we just need to verify that pos
            # is between the last event and the current one.
            return pos < time && pos >= track[index - 1].time;
        }
    }

    void setPos(uint pos) {
        while (!immediatelyFollows(pos)) next();
    }
}

## The event manager deals with all of the scheduling and event dispatching.
class EventManager {
    Controller controller;
    Instrument instrument;
    Sequencer sequencer;
    ChannelMap channelMap;

    # initialize to default project.
    Project project = {};

    Section curSection = {};
    Track recordTrack;
    Array[LoopCursor] trackCursors;

    int mode;

    Time t = {};

    # time that the current loop started.
    uint startTime;

    oper init(Controller controller, Instrument instrument,
              Sequencer sequencer,
              ChannelMap channelMap
              ) :
        controller = controller,
        instrument = instrument,
        sequencer = sequencer,
        channelMap = channelMap {

        project.sections.append(curSection);

        # set up the programs for the synthesizer
        byte i;
        for (chi :in channelMap.programs) {
            instrument.onEvent(ProgramChange(0, i, chi.program));
            ++i;
        }
    }

    ## Return the absolute time in "ticks since the epoch."
    uint getAbsTime() {
        t.setToNow(null);
        return t.secs * 100 + t.nsecs / 10000000;
    }

    ## Returns the time relative to the beginning of the loop (also in ticks).
    uint getRelTime() {
        return getAbsTime() - startTime;
    }

    void endRecord() {
        curSection.markEnding(recordTrack, getRelTime());
        curSection.tracks.append(recordTrack);
        controller.trackAdded();
        basename := FStr() `track$(curSection.nextTrackNumber++).mtrk`;
        MidiWriter writer = {(cwd/basename).writer()};
        recordTrack.writeTo(writer);
        cout `stored track with span $(recordTrack[-1].time)\n`;
        trackCursors = null;
        recordTrack = null;
    }

    void doRecord() {
        controller.changeState(mode, RECORD);
        if (mode == RECORD)
            endRecord();
        cout `record\n`;

        # if we're coming in from "latched" mode, adjust the start time
        if (mode == LATCHED_RECORD && startTime && curSection.span) {
            startTime += (getRelTime() / curSection.span) * curSection.span;
        } else {
            # otherwise, just reset it.
            startTime = getAbsTime();
        }
        mode = RECORD;
        recordTrack = Track('record');
    }

    void doLatchedRecord() {
        # XXX going from play -> latched seems to be broken
        cout `latched\n`;
        if (mode == RECORD)
            endRecord();
        mode = LATCHED_RECORD;
    }

    void doIdle() {
        cout `idle\n`;
        instrument.stop();
        controller.changeState(PLAY, IDLE);
        mode = IDLE;
        trackCursors = null;
    }

    void setTrackCursors(uint ticks) {
        if (trackCursors) {
            for (cur :in trackCursors)
                cur.setPos(ticks);
        }
    }

    ## Sets our current position within the section.
    void setPos(uint ticks) {
        startTime = getAbsTime();
        setTrackCursors(ticks);
    }

    void doPlay() {
        if (!curSection.tracks && mode != RECORD) {
            cout `No tracks to play!\n`;
            return;
        }

        cout `play\n`;
        controller.changeState(mode, PLAY);

        if (mode == RECORD)
            endRecord();
        mode = PLAY;
        setPos(0);
    }

    void doStop() {
        if (mode == RECORD)
            endRecord();

        mode = IDLE;
    }

    void togglePlay() {
        if (mode == PLAY)
            doIdle();
        else
            doPlay();
    }

    ## restore the app to its pristine state
    void clear() {
        cout `clearing state\n`;
        recordTrack = null;
        mode = IDLE;
        startTime = 0;
        project = Project();
        curSection = Section();
        project.sections.append(curSection);
    }


    void onInputEvent(Event event) {
        if (mode == LATCHED_RECORD)
            doRecord();

        event.time = getRelTime();
        if (chev := ChannelEvent.cast(event, null))
            chev.channel = channelMap.currentChannel;
        cout `adding event with time $(event.time): $event\n`;
        instrument.onEvent(event);
        if (mode == RECORD)
            recordTrack.append(event);
    }

    void __playPendingEvents(LoopCursor cur, uint pos) {
        while (!cur.immediatelyFollows(pos)) {
            instrument.onEvent(e := cur.next());
            cout `played event $e at time $(e.time)/$(cur.span) for pos $pos\n`;
        }
    }

    void deleteTrack(uint index) {
        curSection.deleteTrack(index);
        if (trackCursors)
            trackCursors.delete(index);

        # tell the controller
        controller.trackDeleted(index);
    }

    void runOneCycle() {
        relTime := getRelTime();

        # Check for an incoming event on the sequencer, play it and store it
        # if we're recording.
        if (sequencer.hasEvent()) {
            event := sequencer.getEvent();
            if (event)
                onInputEvent(event);
            cout `event is $event\n`;
        }

        # if we're recording, get the next event.
        if (mode == RECORD || mode == PLAY || mode == LATCHED_RECORD) {

            # if we don't currently have a set of cursors, generate them now.
            if (!trackCursors && curSection.tracks) {
                trackCursors =
                    Array[LoopCursor](curSection.tracks.count());
                for (track :in curSection.tracks)
                    trackCursors.append(LoopCursor(track));
            }

            if (trackCursors) {
                # play all of the events in all of the tracks that are due to
                # be played.
                for (cur :in trackCursors) {
                    # calculate the point we're at in this track.
                    trackPos := relTime % cur.span;

                    # play all events up to that point
                    __playPendingEvents(cur, trackPos);
                }
            }
        }
    }
}