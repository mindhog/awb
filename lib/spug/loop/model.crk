# Copyright 2012 Google Inc.  All Rights Reserved.
#
# Spugloop model objects.

import crack.cont.array Array;
import crack.cont.hashmap HashMap;
import crack.cont.treemap TreeMap;
import crack.fs cwd, makePath;
import crack.functor Functor1;
import crack.io cerr, cout, FStr, StringReader, StringWriter;
import crack.lang cmp, makeHashVal, CString, Exception;
import crack.math floor;
import crack.midi.event ChannelEvent, ControlChange, EndTrack, Event,
    MidiReader, MidiWriter, ProgramChange, SeekableEventSource, Track;
import crack.protobuf readMessageFromString, Field, ProtoReader, ProtoWriter;
import spug.loop.instrument Instrument, Orchestra;
import spug.loop.jack SequencerWaveModel, Wave, WaveAdapter, WaveManager,
    WaveModel, WindowBufferAdapter;
import crack.midi.alsa Port, Sequencer;
import crack.protobuf Message;
import crack.serial SerialReader, SerialWriter;
import crack.time Time_add = add, Time, TimeDelta;

@import crack.ann assert, impl, implements, interface;
@import crack.protobuf.ann protobuf;

## Defines a midi bank.  This can be applied to an Orchestra object to change
## the instrument configuration for a given channel.
@interface Bank {
    @abstract void configure(Orchestra orchestra, uint channel);

    @final bool oper >=(Bank other) {
        return uintz(this) >= uintz(other);
    }

    @final bool oper <=(Bank other) {
        return uintz(this) <= uintz(other);
    }
}

class WavePlayerBank : Object @implements Bank {
    void configure(Orchestra orchestra, uint channel) {

    }
}

@protobuf {

    ## A "mark" is a stored position in the section, measured in frames since
    ## the beginning of the section at 44.1k.
    message Mark {

        ## Position in frames.
        optional int32 pos = 1;

        ## Mark name.
        optional string name = 2;
    }

    message SectionOptionalData {
        repeated Mark marks = 1;
    }
}

## This is a "section" of the piece.  A section consists of a group of tracks
## that are played in parallel.  A section consists of one or more "measures"
## which should normally be the size of the shortest track.  Every track
## should completely fill some number of measures.
class Section {

    ## The size of a measure in pulses.  A value of zero is used when there
    ## are no tracks.
    uint measure;

    ## The time span of the section in pulses.
    uint span;

    ## Optional data.
    SectionOptionalData optionalData;

    ## The set of all tracks in the section.
    Array[Track] tracks;

    oper init() : tracks() {}
    oper init(Array[Track] tracks, uint measure, uint span) :
        tracks = tracks,
        measure = measure,
        span = span {
    }

    ## Records the "end of track" time.  If there is only one track it also
    ## sets the measure time.
    ## If 'snapToMeasure' is true, snap the end time and events to the nearest
    ## measure boundary.  That is to say, it changes the end time to the end of the last
    ## measure if that is closer than then end of the next measure and
    ## moves all events past the end of the last measure back to align with
    ## the ending.
    @final void markEnding(Track lastTrack, uint time, bool snapToMeasure) {

        if (!span) {
            span = measure = time;
        # verify that the time is an even multiple of the current span
        } else {

            # If we don't have measure defined, define it now.
            if (!measure)
                measure = time;

            # if the end time is closer to the beginning of the measure than
            # to the end, trim all events to the end of the measure boundary.
            timeInMeasure := time % measure;
            if (timeInMeasure < measure - timeInMeasure) {
                time -= timeInMeasure;
                for (event :in lastTrack)
                    if (event.time > time)
                        event.time = time;
            }

            if (time > span) {
                cout `increasing span: $time / $span\n`;
                multiple := (time - 1) / span + 1;
                span *= multiple;
            }
            time = span;
        }

        lastTrack.add(EndTrack(time));
    }

    @final void deleteTrack(uint index) {
        tracks.delete(index);

        # deal with deleting the last track.
        if (!tracks.count()) {
            span = measure = 0;
            return;
        }

        # recalculate the span
        maxSpan := 0;
        uint t;
        for (track :in tracks) {
            t = track[-1].time;
            if (t > maxSpan)
                maxSpan = t;
        }
        span = t;
    }

    void writeTo(SerialWriter out) {
        out.write(measure);
        out.write(span);
        out.write(tracks.count());

        for (track :in tracks) {

            # write the track name
            out.write(track.name);

            # serialize the track, then write it out as a string since tracks
            # are not delimited.
            StringWriter temp = {};
            MidiWriter mw = {temp};
            track.writeTo(mw);
            mw.flush();
            out.write(temp.makeString());

            # Write the track's optional data (we don't currently preserve
            # this).
            out.write(0);
        }

        # Write the section's optional data.
        if (optionalData)
            optionalData.serialize(ProtoWriter(out));
        else
            out.write(0);
    }

    void readFrom(SerialReader src) {
        measure = src.readUInt();
        span = src.readUInt();
        trackCount := src.readUInt();

        for (int i = 0; i < trackCount; ++i) {
            trackName := src.readString();
            MidiReader mr = {StringReader(src.readString())};
            tracks.append(track := mr.readTrack(trackName));

            # Read and discard the optional track data.
            src.readString();

            cout `track $i:\n$track\n`;
        }

        # Read the optional data.
        optionalDataString := src.readString();
        optionalData = SectionOptionalData();
        readMessageFromString(optionalData, optionalDataString);
    }
}

## Global play modes.
const int IDLE = 0, RECORD = 1, PLAY = 2, LATCHED_RECORD = 3;

# message ProjectOptional {
#   repeated string wavefile = 1;
# }
const PROJ_WAVEFILE := 1;

## This is the main class representing a project.
class Project {
    Array[Section] sections = {};

    ## The next section number that hasn't been used as part of a section name.
    int nextSectionNumber;

    ## The set of all wave files known to the project.
    Array[String] waveFiles = {};

    ## Unknown fields, preserved so we can write them back.
    Array[Field] __unknownFields = {};

    # Special midi banks.
    TreeMap[uint16, Bank] __banks;

    ## Write the current project to a file.
    void writeTo(SerialWriter out) {
        # version number
        out.write(1);

        # Write the optional project data.
        StringWriter outBack = {};
        opt := ProtoWriter(outBack);
        for (waveFile :in waveFiles)
            opt.write(1, waveFile);
        for (unknown :in __unknownFields)
            opt.write(unknown);
        out.write(outBack.string());

        # write the section count, then each of the sections.
        out.write(sections.count());
        for (section :in sections)
            section.writeTo(out);
    }

    void readFrom(SerialReader src) {
        sections.clear();
        if ((v := src.readUInt()) != 1)
            throw Exception(FStr() `Invalid varsion number: $v`);

        # Read optional data.
        optionalData := src.readString();
        opt := ProtoReader(StringReader(optionalData));
        while (field := opt.readField()) {
            if (field.id == PROJ_WAVEFILE)
                waveFiles.append(field.getString());
            else
                __unknownFields.append(field);
        }

        sectionCount := src.readUInt();
        for (i := 0; i < sectionCount; ++i) {
            section := Section();
            section.readFrom(src);
            sections.append(section);
        }
    }
}

@interface Controller {
    @abstract void changeState(int oldState, int newState);
    @abstract void trackAdded();
    @abstract void trackDeleted(uint index);
    @abstract void sectionCreated();
    @abstract void sectionChanged();
}

Array[String] programNames = [
    'Acoustic Grand Piano',
    'Bright Acoustic Piano',
    'Electric Grand Piano',
    'Honky-tonk Piano',
    'Electric Piano 1',
    'Electric Piano 2',
    'Harpsichord',
    'Clavi',
    'Celesta',
    'Glockenspiel',
    'Music Box',
    'Vibraphone',
    'Marimba',
    'Xylophone',
    'Tubular Bells',
    'Dulcimer',
    'Drawbar Organ',
    'Percussive Organ	',
    'Rock Organ',
    'Church Organ',
    'Reed Organ',
    'Accordion',
    'Harmonica',
    'Tango Accordion',
    'Acoustic Guitar (nylon)',
    'Acoustic Guitar (steel)',
    'Electric Guitar (jazz)',
    'Electric Guitar (clean)',
    'Electric Guitar (muted)',
    'Overdriven Guitar',
    'Distortion Guitar',
    'Guitar harmonics',
    'Acoustic Bass',
    'Electric Bass (finger)',
    'Electric Bass (pick)',
    'Fretless Bass',
    'Slap Bass 1	',
    'Slap Bass 2	',
    'Synth Bass 1',
    'Synth Bass 2',
    'Violin',
    'Viola',
    'Cello',
    'Contrabass',
    'Tremolo Strings',
    'Pizzicato Strings',
    'Orchestral Harp',
    'Timpani',
    'String Ensemble 1',
    'String Ensemble 2',
    'SynthStrings 1',
    'SynthStrings 2',
    'Choir Aahs',
    'Voice Oohs',
    'Synth Voice',
    'Orchestra Hit',
    'Trumpet',
    'Trombone',
    'Tuba',
    'Muted Trumpet',
    'French Horn',
    'Brass Section',
    'SynthBrass 1',
    'SynthBrass 2',
    'Soprano Sax',
    'Alto Sax',
    'Tenor Sax',
    'Baritone Sax',
    'Oboe',
    'English Horn',
    'Bassoon',
    'Clarinet',
    'Piccolo',
    'Flute',
    'Recorder',
    'Pan Flute',
    'Blown Bottle',
    'Shakuhachi',
    'Whistle',
    'Ocarina',
    'Lead 1 (square)',
    'Lead 2 (sawtooth)',
    'Lead 3 (calliope)',
    'Lead 4 (chiff)',
    'Lead 5 (charang)',
    'Lead 6 (voice)',
    'Lead 7 (fifths)',
    'Lead 8 (bass + lead)',
    'Pad 1 (new age)',
    'Pad 2 (warm)',
    'Pad 3 (polysynth)',
    'Pad 4 (choir)',
    'Pad 5 (bowed)',
    'Pad 6 (metallic)',
    'Pad 7 (halo)',
    'Pad 8 (sweep)',
    'FX 1 (rain)',
    'FX 2 (soundtrack)',
    'FX 3 (crystal)',
    'FX 4 (atmosphere)',
    'FX 5 (brightness)',
    'FX 6 (goblins)',
    'FX 7 (echoes)',
    'FX 8 (sci-fi)',
    'Sitar',
    'Banjo',
    'Shamisen',
    'Koto',
    'Kalimba',
    'Bag pipe',
    'Fiddle',
    'Shanai',
    'Tinkle Bell',
    'Agogo',
    'Steel Drums',
    'Woodblock',
    'Taiko Drum',
    'Melodic Tom',
    'Synth Drum',
    'Reverse Cymbal',
    'Guitar Fret Noise',
    'Breath Noise',
    'Seashore',
    'Bird Tweet',
    'Telephone Ring',
    'Helicopter',
    'Applause',
    'Gunshot',

    # 128 - fake programs
    'Drumz',
];

class ChannelInfo {
    byte program;

    oper init(byte program) : program = program {}
    String getProgramName() { return programNames[program]; }
}

class ChannelMap {
    byte currentChannel;
    Array[ChannelInfo] programs = [
        ChannelInfo(0), # 0 Grand Piano
        ChannelInfo(32), # 1 Bass
        ChannelInfo(48), # 2 strings
        ChannelInfo(18), # 3 Rock Organ
        ChannelInfo(3),  # 4 Honky Tonk
        ChannelInfo(80), # 5 Synth (square)
        ChannelInfo(30), # 6 Overdrive Guitar
        ChannelInfo(66), # 7 Tenor Sax
        ChannelInfo(62), # 8 Brass Section
        ChannelInfo(128), # channel 9, this is going to be drums
    ];

    ChannelInfo getCurrentChannel() { return programs[currentChannel]; }
}

class LoopCursor {
    Track track;
    int index;

    # time of the current position and span of the entire track.
    uint time, span;
    oper init(Track track) : track = track {
        time = track[0].time;

        # make sure our last event is an EndTrack.
        EndTrack.cast(track[-1]);
        span = track[-1].time;
    }

    Event elem() { return track[index] }

    Event next() {
        cur := track[index];
        ++index;
        if (index == track.count() - 1) {
            # make sure we are at an end event.
            EndTrack.cast(track[index]);
            index = 0;
        }
        time = track[index].time;
        return cur;
    }

    ## Returns true if the event is the next event in the track following
    ## 'pos'.
    bool immediatelyFollows(uint pos) {
        if (index == 0) {
            if (track.count() == 1)
                return false;
            # the last event is the end track marker, check to see that pos is
            # either greater than the /next to last/ event or less than the
            # current one.
            return pos >= track[-2].time || pos < time;
        } else {
            # if this isn't the first event, we just need to verify that pos
            # is between the last event and the current one.
            return pos < time && pos >= track[index - 1].time;
        }
    }

    ## True if the track is not empty.
    bool isTrue() { return track.count() > 1 }

    void setPos(uint pos) {
        while (!immediatelyFollows(pos)) next();
    }
}

const MILLION := 1000000;
const BILLION := MILLION * 1000;

## The event manager deals with all of the scheduling and event dispatching.
class EventManager {
    Controller controller;
    Orchestra instrument;
    Sequencer sequencer;
    ChannelMap channelMap;
    Port outPort;

    # initialize to default project.
    Project project = {};

    Section curSection = {};
    int curSectionIndex, nextSectionIndex;
    Track recordTrack;
    Array[LoopCursor] trackCursors;
    TreeMap[int, Port] __portCache = {};

    # Name of the project file.
    String projectFileName = 'noname';

    # The wave manager.  Manages the direct PCM wave system and interface to
    # jack.
    WaveManager waveMan;

    # Mapping from event byte values to special processing functions for those
    # events.  Currently only control changes are supported and these are
    # represented by an integer of form (channel << 8 | controller).
    HashMap[uint, Functor1[void, Event]] eventProcessors = {};

    int mode;

    # time that the current loop started and a holder for the current time.
    Time startTime = {}, t = {};

    # last time that we acted upon.
    float lastTime;

    # if nextSectionIndex is true, this is the next time to change the section
    uint nextSectionStartTime;

    # Both Tempo and PPB should be defined per section.  Per-section tempo
    # should be defined relative to the project tempo, tempo should be in the
    # project, what we have here should probably be either a scaling factor or
    # an override of the project level value.

    ## Global tempo in BPM.
    uint tempo = 120;

    ## Global pulses-per-beat.
    uint ppb = 96;

    oper init(Controller controller, Orchestra instrument,
              Sequencer sequencer,
              ChannelMap channelMap
              ) :
        controller = controller,
        instrument = instrument,
        sequencer = sequencer,
        channelMap = channelMap {

        project.sections.append(curSection);

        # set up the programs for the synthesizer
        byte i;
        for (chi :in channelMap.programs) {
            instrument.onEvent(ProgramChange(0, i, chi.program & 0x7F));
            ++i;
        }
    }

    ## Returns the number of midi clock ticks (aka "pulses") for the specified
    ## number of microseconds.
    @final int usecsToTicks(int64 usecs) {
        # This is a bit convoluted because we're trying to do it with integer
        # math without truncating anything signficant.  What we're trying to say
        # is: seconds * pulsesPerSecond
        # where: pulsesPerSecond = (BPM / 60) * PPB
        #        seconds = usecs / MILLION
        # so: (usecs / MILLION) * ((BPM / 60) * PPB)
        #     (usecs / MILLION) * ((BPM * PPB) / 60)
        #     (usecs * BPM * PPB) / (60 * MILLION)
        return (usecs * int64(tempo) * int64(ppb)) / int64(60 * MILLION);
    }

    int64 ticksToUSecs(int ticks) {
        # This just inverts the math above:
        #   ticks = (nsecs * BPM * PPB) / (60 * MILLION)
        # so:
        #   (ticks * 60 * MILLION) / (BPM * PPB) = nsecs
        return (60 * MILLION * int64(ticks)) / (int64(tempo) * int64(ppb));
    }

    ## Record the current time as the start time.
    void markStartTime() {
        startTime.setToNow(null);
    }

    ## Returns the time relative to when we started looping (also in ticks).
    uint getRelTime() {
        t.setToNow(null);
        int64 usecs = int64(t.secs - startTime.secs) * MILLION +
                      (t.nsecs - startTime.nsecs) / 1000;
        result := usecsToTicks(usecs);
        return result;
    }

    ## Adds a track to the current section, notifies the controller.
    void addTrack(Track track, uint endTime) {
        curSection.markEnding(track, endTime, true);
        curSection.tracks.append(track);
        controller.trackAdded();
    }

    void endRecord() {
        addTrack(recordTrack, getRelTime());
        trackCursors = null;
        recordTrack = null;
    }

    void doRecord() {
        controller.changeState(mode, RECORD);
        if (mode == RECORD)
            endRecord();
        cout `record\n`;

        # if we're coming in from "latched" mode, adjust the start time
        if (mode == LATCHED_RECORD && startTime.secs && curSection.span) {
            usecs := ticksToUSecs((getRelTime() / curSection.span) *
                                  curSection.span);
            startTime.nsecs += int32((usecs % MILLION) * 1000);
            startTime.secs += int32(usecs / MILLION +
                                    startTime.nsecs / BILLION);
        } else {
            # otherwise, just reset it.
            markStartTime();
        }

        # Start the wave manager if we're coming in from IDLE.
        if (waveMan && mode == IDLE)
            waveMan.unpause();

        mode = RECORD;
        recordTrack = Track(channelMap.getCurrentChannel().getProgramName());
    }

    void doLatchedRecord() {
        # XXX going from play -> latched seems to be broken
        cout `latched\n`;
        if (mode == RECORD)
            endRecord();
        mode = LATCHED_RECORD;
    }

    void doIdle() {
        cout `idle\n`;
        instrument.stop();
        controller.changeState(PLAY, IDLE);
        mode = IDLE;
        trackCursors = null;
        if (waveMan)
            waveMan.pause();
    }

    void setTrackCursors(uint ticks) {
        if (trackCursors) {
            for (cur :in trackCursors)
                cur.setPos(ticks);
        }
    }

    ## Sets our current position within the section.
    void setPos(uint ticks) {
        markStartTime();
        setTrackCursors(ticks);
    }

    void doPlay() {
        if (!curSection.tracks && mode != RECORD && !waveMan) {
            cout `No tracks to play!\n`;
            return;
        }

        cout `play\n`;
        controller.changeState(mode, PLAY);

        if (mode == RECORD)
            endRecord();
        mode = PLAY;

        # This is a hack to deal with the looping/wave editing dichotomy - if
        # we're doing midi looping (as evidenced by the presence of midi
        # tracks) then we set the current position to zero.
        if (!waveMan) {
            setPos(0);
        } else {
            # Mark the start time but then offset it backwards by the current
            # position of the wave managaer.
            markStartTime();

            # Get the current frame number and convert to seconds since the
            # beginning of the wave.
            timeSinceStart :=
                float(waveMan.tell()) / float(waveMan.getSampleRate());
            wholeSecs := floor(timeSinceStart);
            nsecs := (timeSinceStart - wholeSecs) * 1e+9;
            startTime = Time_add(startTime,
                                 TimeDelta(-int32(wholeSecs), -int32(nsecs))
                                 );
        }
        if (waveMan)
            waveMan.unpause();
    }

    void doStop() {
        if (mode == RECORD)
            endRecord();

        mode = IDLE;
        if (waveMan)
            waveMan.unpause();
    }

    void togglePlay() {
        if (mode == PLAY)
            doIdle();
        else
            doPlay();
    }

    ## restore the app to its pristine state
    void clear() {
        cout `clearing state\n`;
        recordTrack = null;
        mode = IDLE;
        startTime.secs = startTime.nsecs = 0;
        project = Project();
        curSection = Section();
        project.sections.append(curSection);
    }


    void onInputEvent(Event event) {
        if (mode == LATCHED_RECORD)
            doRecord();

        event.time = getRelTime();
        cout `got event $event\n`;

        # Divert bound events to the correct event processor.
        if ((cc := ControlChange.cast(event, null)) &&
            (proc :=
                eventProcessors.get((uint(cc.channel) << 8) | cc.controller)
             )
            ) {
            proc(cc);
            return;
        }

        if (chev := ChannelEvent.cast(event, null))
            chev.channel = channelMap.currentChannel;

        instrument.onEvent(event);
        if (mode == RECORD)
            recordTrack.append(event);
    }

    void __playPendingEvents(LoopCursor cur, uint pos) {
        while (cur && !cur.immediatelyFollows(pos)) {
            instrument.onEvent(e := cur.next());
#            cout `played event $e at time $(e.time)/$(cur.span) for pos $pos\n`;
        }
    }

    void deleteTrack(uint index) {
        trackChannel := ChannelEvent.cast(curSection.tracks[index][0]).channel;
        instrument.getChild(trackChannel).stop();
        curSection.deleteTrack(index);
        if (trackCursors)
            trackCursors.delete(index);

        # tell the controller
        controller.trackDeleted(index);
    }

    void __changeSection() {
        curSectionIndex = nextSectionIndex;
        curSection = project.sections[curSectionIndex];
        trackCursors = null;
        controller.sectionChanged();
    }

    ## Change the section at the end of the next loop or immediately if we're
    ## idle.
    void __scheduleSectionChange() {
        if (mode == IDLE)
            __changeSection();
        else {
            relTime := getRelTime();
            nextSectionStartTime =
                (relTime / curSection.span + 1) * curSection.span;
        }
    }

    ## Create a new section.  If we're in "play" mode, make the new section
    ## the next section to play.
    ## seedTracks: tracks to seed the new section with.
    void createSection(Array[Track] seedTracks) {
        nextSectionIndex = project.sections.count();

        # if there are seed tracks, use the current section's measure and
        # obtain the span from the seed track.  Otherwise just create an empty
        # section.
        Section newSection;
        if (seedTracks) {
            uint span;
            for (track :in seedTracks) {
                t := track[-1].time;
                if (t > span)
                    span = t;
            }
            newSection = Section(seedTracks, curSection.measure, span);
        } else {
            newSection = Section();
        }

        project.sections.append(newSection);

        controller.sectionCreated();
        __scheduleSectionChange();
    }

    int getSectionCount() { return project.sections.count(); }
    int getSectionIndex() { return curSectionIndex; }
    int getNextSectionIndex() { return nextSectionIndex; }
    void setNextSection(int index) {
        nextSectionIndex = index;
        __scheduleSectionChange();
    }

    void runOneCycle() {
        relTime := getRelTime();

        # see if we need to change sections.
        if ((nextSectionIndex != curSectionIndex) && mode == PLAY &&
            relTime >= nextSectionStartTime
            ) {
            instrument.stop();
            __changeSection();
            markStartTime();
        }

        # Check for a incoming events on the sequencer, play it and store it
        # if we're recording.
        while (sequencer.hasEvent()) {
            event := sequencer.getEvent();
            if (event)
                onInputEvent(event);
        }

        # if we're recording, get the next event.
        if (mode == RECORD || mode == PLAY || mode == LATCHED_RECORD) {

            # if we don't currently have a set of cursors, generate them now.
            if (!trackCursors && curSection.tracks) {
                trackCursors =
                    Array[LoopCursor](curSection.tracks.count());
                for (track :in curSection.tracks)
                    trackCursors.append(LoopCursor(track));
            }

            if (trackCursors) {
                # play all of the events in all of the tracks that are due to
                # be played.
                for (cur :in trackCursors) {
                    # safety check
                    if (!cur.span)
                        continue;

                    # calculate the point we're at in this track.
                    trackPos := relTime % cur.span;

                    # play all events up to that point
                    __playPendingEvents(cur, trackPos);
                }
            }
        }

        lastTime = relTime;
    }

    ## Returns the fraction of time position / section span as of the last
    ## runOneCycle().
    float getTimeFraction() {
        return (lastTime % curSection.span) / curSection.span;
    }

    ## Returns true if we're playing existing tracks (either as play or
    ## record).
    @final bool playingExistingTracks() {
        return mode == PLAY ||
               (mode == RECORD || mode == LATCHED_RECORD) && curSection.tracks;
    }

    ## Store the track to the current filename.
    void save() {
        project.writeTo(SerialWriter(makePath(projectFileName).writer()));
    }

    ## Load the track and set the filename.  Does nothing if the file doesn't
    ## exist.
    void load(String filename) {
        projectFileName = filename;
        path := makePath(filename);
        if (path.exists()) {
            project.readFrom(SerialReader(path.reader()));
            curSection = project.sections[0];
            cout `tracks in cur section: $(curSection.tracks.count())\n`;
            controller.sectionChanged();
        }
    }

    ## Map a wave file to the current section.
    ## The wave manager must have been defined.
    WindowBufferAdapter mapWaveFile(String filename) {
        @assert(waveMan);
        result := waveMan.addFile(filename);

        # Calculate end time in microseconds.
        endTime := int64(result.getFrameCount()) * 1000000 /
                   int64(result.getRate());
        if ((spanInTicks := usecsToTicks(endTime)) > curSection.span)
            curSection.span = spanInTicks;

        curSection.tracks.append(
            Track( filename, Array[Event]![EndTrack(usecsToTicks(endTime))] )
        );
        controller.trackAdded();
        return result;
    }

    WaveAdapter addWaveModel(WaveModel model, String trackName) {
        @assert(waveMan);
        result := waveMan.addWaveModel(model);
        spanInUSecs := int64(model.frames) * 1000000 / 44100;
        spanInTicks := usecsToTicks(spanInUSecs);
        curSection.tracks.append(
            Track(trackName, Array[Event]![EndTrack(spanInTicks)])
        );
        if (spanInTicks > curSection.span)
            curSection.span = spanInTicks;
        controller.trackAdded();
        return result;
    }

    Port getOutPort(int client, int portNum) {
        port := __portCache.get(client << 16 | portNum);
        if (!port) {
            port = sequencer.makeWritePort(
                CString(FStr() `crack-$client:$portNum`)
            );
            __portCache[client << 16 | portNum] = port;
        }
        port.connectTo(client, portNum);
        return port;
    }

}

